<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube 3D</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      position: relative;
    }
    
    #container {
      width: 600px;
      height: 600px;
      background-color: #ffffff;
      border: 2px solid #ccc;
      margin-bottom: 20px;
      position: relative;
    }
    
    #controls {
      display: flex;
      gap: 20px;
    }
    
    button {
      padding: 15px 30px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:active {
      background-color: #3d8b40;
    }
    
    /* Croix directionnelle */
    #dpad-container {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 140px;
      height: 140px;
    }
    
    .dpad-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: #555;
      border: 2px solid #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      transition: background-color 0.2s, transform 0.1s;
      transform: rotate(0deg);
      user-select: none;
    }
    
    .dpad-button:hover {
      background-color: #666;
    }
    
    .dpad-button:active {
      background-color: #777;
      transform: rotate(0deg) scale(0.95);
    }
    
    .dpad-button span {
      transform: rotate(0deg);
      display: block;
    }
    
    #dpad-UR {
      top: 7%;
      left: 7%;
      transform: translate(0%, 0%) rotate(0deg);
    }
    
    #dpad-BR {
      top: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-UL {
      bottom: 7%;
      left: 7%;
      transform: translateX(0%, 0%)  rotate(0deg);
    }
    
    #dpad-BL {
      bottom: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      background-color: #d35400;
      border-color: #a04000;
    }
    
    #dpad-center:hover {
      background-color: #e67e22;
    }
    
    #dpad-center:active {
      background-color: #ca6f1e;
      transform: translate(-50%, -50%) rotate(45deg) scale(0.95);
    }
    
    /* Compteurs de jauges */
    #gauges-display {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }
    
    .gauge {
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      padding: 6px 12px;
      min-width: 140px;
    }
    
    .gauge-label {
      font-size: 10px;
      font-weight: bold;
      color: #aaaaaa;
      margin: 0 0 3px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .gauge-value {
      font-size: 18px;
      font-weight: bold;
      margin: 0;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
    }
    
    #heures-value {
      color: #3498db;
    }
    
    #confrontation-value {
      color: #e74c3c;
    }
    
    #alignement-value {
      color: #f39c12;
    }
    
    #alignement-value.positive {
      color: #9b59b6;
    }
    
    #alignement-value.negative {
      color: #27ae60;
    }
    
    /* Volet de confrontation */
    #confrontation-panel {
      position: fixed;
      top: 0;
      right: -100%;
      width: 100%;
      height: 100%;
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453079/D_bureau_b2b5gx.png');
      background-size: cover;
      background-position: center;
      background-color: #2c3e50;
      transition: right 0.5s ease-in-out;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-end;
    }
    
    #confrontation-panel.active {
      right: 0;
    }
    
    /* Images des personnages */
    .character-container {
      position: absolute;
      bottom: 5%;
      height: 70%;
      display: flex;
      align-items: flex-end;
      z-index: 1001;
    }
    
    #antagonist-image {
      left: 0;
      max-height: 100%;
      object-fit: contain;
    }
    
    #player-image {
      right: 0;
      max-height: 100%;
      object-fit: contain;
    }
    
    .character-image {
      max-height: 75%;
      height: auto;
      filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.5));
    }
    
    /* Bloc de dialogue */
    #dialogue-container {
      position: relative;
      width: 100%;
      height: 25%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 20px;
      z-index: 1002;
    }
    
    #character-name-box {
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #ffffff;
      border-radius: 8px;
      padding: 8px 20px;
      margin-bottom: -2px;
      margin-left: 20px;
      z-index: 1003;
    }
    
    #character-name {
      font-size: 18px;
      font-weight: bold;
      color: white;
      text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
      margin: 0;
    }
    
    #dialogue-box {
      background-color: rgba(20, 20, 40, 0.85);
      border: 3px solid #444;
      border-radius: 12px;
      padding: 25px 30px;
      width: 100%;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #dialogue-text {
      color: white;
      font-size: 20px;
      line-height: 1.6;
      margin: 0 0 15px 0;
      flex-grow: 1;
    }
    
    #dialogue-controls {
      display: flex;
      justify-content: flex-end;
      gap: 15px;
      position: relative;
    }
    
    .dialogue-button {
      padding: 12px 25px;
      font-size: 16px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .dialogue-button:hover {
      background-color: #2980b9;
    }
    
    .dialogue-button:active {
      background-color: #21618c;
    }
    
    #close-confrontation-btn {
      background-color: #e74c3c;
      position: absolute;
      right: 0;
      bottom: 0;
      display: none;
      pointer-events: none;
    }
    
    #close-confrontation-btn.visible {
      display: inline-block;
      pointer-events: auto;
    }
    
    #close-confrontation-btn:hover {
      background-color: #c0392b;
    }
    
    #close-confrontation-btn:active {
      background-color: #a93226;
    }
    
    /* Mini-jeu de cartes */
    #cards-game-container {
      position: absolute;
      bottom: 26%;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      z-index: 1002;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    
    #cards-game-container.visible {
      visibility: visible;
      opacity: 1;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7);
    }
    
    .card-player-hand {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
    }
    
    .card-player-played {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      border-color: #3498db;
    }
    
    .card-npc-hand {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
    }
    
    .card-npc-played {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      border-color: #e74c3c;
    }
    
    .card-center {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      background-color: rgba(50, 50, 50, 0.5);
      border: 2px dashed rgba(255, 255, 255, 0.3);
    }
    
    /* Positions spÃ©cifiques dans la grille */
    #card-player-1 { grid-column: 1; grid-row: 1; }
    #card-player-2 { grid-column: 2; grid-row: 1; }
    #card-player-3 { grid-column: 3; grid-row: 1; }
    #card-player-played { grid-column: 1; grid-row: 2; }
    #card-center { grid-column: 2; grid-row: 2; }
    #card-npc-played { grid-column: 3; grid-row: 2; }
    #card-npc-1 { grid-column: 1; grid-row: 3; }
    #card-npc-2 { grid-column: 2; grid-row: 3; }
    #card-npc-3 { grid-column: 3; grid-row: 3; }
    
    /* Affichage du rÃ©sultat de tour */
    #result-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 72px;
      font-weight: bold;
      color: white;
      text-shadow: 
        -3px -3px 0 #000,
        3px -3px 0 #000,
        -3px 3px 0 #000,
        3px 3px 0 #000,
        0 0 20px rgba(0, 0, 0, 0.8);
      z-index: 1003;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #result-display.show {
      opacity: 1;
      animation: shake 0.5s infinite;
    }
    
    @keyframes shake {
      0%, 100% { 
        transform: translate(-50%, -50%) rotate(0deg) scale(1);
      }
      10% { 
        transform: translate(-48%, -52%) rotate(-2deg) scale(1.05);
      }
      20% { 
        transform: translate(-52%, -48%) rotate(2deg) scale(0.95);
      }
      30% { 
        transform: translate(-49%, -51%) rotate(-1deg) scale(1.02);
      }
      40% { 
        transform: translate(-51%, -49%) rotate(1deg) scale(0.98);
      }
      50% { 
        transform: translate(-50%, -50%) rotate(0deg) scale(1.03);
      }
      60% { 
        transform: translate(-52%, -51%) rotate(-2deg) scale(1.01);
      }
      70% { 
        transform: translate(-48%, -49%) rotate(2deg) scale(0.97);
      }
      80% { 
        transform: translate(-51%, -50%) rotate(-1deg) scale(1.04);
      }
      90% { 
        transform: translate(-49%, -52%) rotate(1deg) scale(0.99);
      }
    }
    
    /* Indicateur de zone cliquable */
    #click-indicator {
      position: absolute;
      border: 4px solid gold;
      border-radius: 8px;
      background-color: rgba(255, 215, 0, 0.2);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
      z-index: 1004;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      animation: pulse-glow 0.6s infinite alternate;
    }
    
    #click-indicator.show {
      opacity: 1;
    }
    
    @keyframes pulse-glow {
      0% {
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
        border-color: gold;
      }
      100% {
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 215, 0, 0.5);
        border-color: rgba(255, 215, 0, 0.7);
      }
    }
    
    /* Affichage des points gagnÃ©s/perdus */
    #points-display {
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 42px;
      font-weight: bold;
      z-index: 1005;
      pointer-events: none;
      opacity: 0;
      display: none;
      text-shadow: 
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000,
        0 0 15px rgba(0, 0, 0, 0.8);
    }
    
    #points-display.show {
      opacity: 1;
      animation: float-up 2s ease-out forwards;
    }
    
    @keyframes float-up {
      0% {
        transform: translateY(0) scale(0.8);
        opacity: 0;
      }
      10% {
        opacity: 1;
        transform: translateY(-5px) scale(1.1);
      }
      90% {
        opacity: 1;
        transform: translateY(-15px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
    }

    /* Overlays bonus / piÃ¨ge */
    #bonus-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 260px;
      height: 360px;
      background-color: rgba(0, 0, 0, 0.8);
      border: 3px solid #f1c40f;
      border-radius: 12px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.8);
    }

    #bonus-overlay-image {
      max-width: 100%;
      max-height: 100%;
      display: none;
    }

    #bonus-overlay-text {
      display: none;
      color: #e74c3c;
      font-size: 42px;
      font-weight: bold;
      text-align: center;
      text-shadow:
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000;
    }

    #bonus-alert {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 14px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #f1c40f;
      font-size: 14px;
      font-weight: bold;
      border-radius: 6px;
      border: 1px solid rgba(241, 196, 15, 0.7);
      display: none;
      z-index: 2001;
      pointer-events: none;
      text-shadow: 1px 1px 2px #000;
    }

  </style>
</head>
<body>
  <!-- Volet de confrontation -->
  <div id="confrontation-panel">
    <!-- Images des personnages -->
    <div class="character-container" id="antagonist-image">
      <img src="https://res.cloudinary.com/dgrcmakbt/image/upload/v1764444404/ChatGPT_Image_27_nov._2025_21_35_18_mfe5bx.png" alt="Antagoniste" class="character-image">
    </div>
    <div class="character-container" id="player-image">
      <img src="https://res.cloudinary.com/dgrcmakbt/image/upload/v1764444404/ChatGPT_Image_27_nov._2025_21_35_18_mfe5bx.png" alt="Joueur" class="character-image">
    </div>
    
    <!-- Mini-jeu de cartes -->
    <div id="cards-game-container">
      <!-- Ligne du haut : Main du joueur (3 cartes) -->
      <div class="card card-player-hand" id="card-player-1"></div>
      <div class="card card-player-hand" id="card-player-2"></div>
      <div class="card card-player-hand" id="card-player-3"></div>
      
      <!-- Ligne du milieu : Cartes jouÃ©es -->
      <div class="card card-player-played" id="card-player-played"></div>
      <div class="card card-center" id="card-center"></div>
      <div class="card card-npc-played" id="card-npc-played"></div>
      
      <!-- Ligne du bas : Main du NPC (3 cartes) -->
      <div class="card card-npc-hand" id="card-npc-1"></div>
      <div class="card card-npc-hand" id="card-npc-2"></div>
      <div class="card card-npc-hand" id="card-npc-3"></div>
    </div>
    
    <!-- Affichage du rÃ©sultat -->
    <div id="result-display"></div>
    
    <!-- Indicateur de zone cliquable -->
    <div id="click-indicator"></div>
    
    <!-- Affichage des points gagnÃ©s/perdus -->
    <div id="points-display"></div>
    
    <!-- Bloc de dialogue -->
    <div id="dialogue-container">
      <div id="character-name-box">
        <p id="character-name">Nom de l'antagoniste</p>
      </div>
      <div id="dialogue-box">
        <p id="dialogue-text">Bonjour je suis le Pion nÂ° 1</p>
        <div id="dialogue-controls">
          <button class="dialogue-button" id="next-page-btn">Next Page</button>
          <button class="dialogue-button" id="close-confrontation-btn">Refermer</button>
        </div>
      </div>
    </div>
  </div>
  
  <div id="container">
    <!-- Affichage des jauges -->
    <div id="gauges-display">
      <div class="gauge">
        <p class="gauge-label">Heures d'EnquÃªte</p>
        <p class="gauge-value" id="heures-value">15</p>
      </div>
      <div class="gauge">
        <p class="gauge-label">Confrontation</p>
        <p class="gauge-value" id="confrontation-value">0</p>
      </div>
      <div class="gauge">
        <p class="gauge-label">Alignement</p>
        <p class="gauge-value" id="alignement-value">0</p>
      </div>
    </div>

    <!-- Overlays pour les bonus/piÃ¨ges -->
    <div id="bonus-overlay">
      <img id="bonus-overlay-image" src="" alt="Bonus" />
      <div id="bonus-overlay-text"></div>
    </div>
    <div id="bonus-alert"></div>
    
    <!-- Croix directionnelle en X -->
    <div id="dpad-container">
      <div class="dpad-button" id="dpad-UR">
        <span>â‡–</span>
      </div>
      <div class="dpad-button" id="dpad-BR">
        <span>â‡—</span>
      </div>
      <div class="dpad-button" id="dpad-BL">
        <span>â‡˜</span>
      </div>
      <div class="dpad-button" id="dpad-UL">
        <span>â‡™</span>
      </div>
      <div class="dpad-button" id="dpad-center">
        <span>ðŸ”¥</span>
      </div>
    </div>
  </div>
  <div id="controls">
    <button id="rotateLeftBtn">Rotate -90Â°</button>
    <button id="rotateRightBtn">Rotate 90Â°</button>
    <button id="zoomBtn">Zoom</button>
    <button id="resetBtn">Recommencer</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, checkerboard, skysphere;
    let bonusItems = [];
    let pions = []; // Tableau pour stocker tous les pions
    let redPion = null; // RÃ©fÃ©rence au pion rouge
    let isRotating = false;
    let targetRotation = 0;
    let isZoomed = false;
    let isZooming = false;
    let targetCameraPos = { x: 0, y: 12, z: 10 };
    let targetCameraLookAt = { x: 0, y: 0, z: 0 };
    const boardSize = 15;
    const squareSize = 0.6;
    const pionTypes = [
      { color: '#ff0000', count: 1 },  // 1 pion rouge
      { color: '#00ff00', count: 5 },  // 5 pions verts
      { color: '#9900ff', count: 3 }   // 3 pions violets
    ];


    let roadPositions = []; // Liste des positions de routes (cases gris clair)
    let cityMap = []; // Carte de la ville
    let squareMeshes = {}; // Dictionnaire pour accÃ©der aux meshes des cases
    let accessibleCells = []; // Cases accessibles au pion rouge
    let isPlayerTurn = true; // Tour du joueur
    let confrontedPion = null; // Pion qui a dÃ©clenchÃ© la confrontation
    let currentDialoguePage = 0; // Page actuelle du dialogue
    let currentRotationStep = 0; // Ã‰tape de rotation actuelle (0, 1, 2, 3 pour 0Â°, 90Â°, 180Â°, 270Â°)
    const moveRange = 3; // Range de dÃ©placement
    
    // Jauges de points du joueur
    let heuresEnquete = 15; // Points de dÃ©placement
    let pointsConfrontation = 0; // Points de confrontation (rÃ©initialisÃ©s aprÃ¨s chaque confrontation)
    let pointsAlignement = 0; // Points d'alignement/vertu (peuvent Ãªtre positifs ou nÃ©gatifs)
    let confrontationCount = 0; // Nombre de confrontations effectuÃ©es
    let startTurnPosition = { row: 0, col: 0 }; // Position au dÃ©but du tour
    let pointsGagnesConfrontation = 0; // Total des points gagnÃ©s/perdus pendant la confrontation actuelle
    
    // Inventaire de cartes collectÃ©es
    let cartesCollectees = []; // Inventaire global du joueur

    let detectiveTexture = null;

    // Animation "idle" du dÃ©tective (4 frames sur la sprite-sheet 2x2)
    let detectiveFrameIndex = 0;
    let lastDetectiveFrameTime = 0;
    const detectiveFrameDuration = 200; // durÃ©e d'une frame en ms (~5 fps)
    const detectiveIdleSequence = ['SE', 'SW', 'NE', 'NW']; 


    // Base de donnÃ©es des cartes
    const cardsDatabase = [
      { nom: "Pierre", vsPierre: 2, vsFeuille: 0, vsCiseaux: 1, vsPuits: 0, vsFeu: 1, vsSablier: 0, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512932/card000002_fqmuqv.png" },
      { nom: "Feuille", vsPierre: 1, vsFeuille: 2, vsCiseaux: 0, vsPuits: 1, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 0, vsPie: 1, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512932/card000003_wmqjnf.png" },
      { nom: "Ciseaux", vsPierre: 0, vsFeuille: 1, vsCiseaux: 2, vsPuits: 0, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 1, vsPie: 0, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512933/card000004_jvc95e.png" },
      { nom: "Puits", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 2, vsFeu: 1, vsSablier: 0, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 3, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721025/card000005_vwvcpu.png" },
      { nom: "Feu", vsPierre: 0, vsFeuille: 1, vsCiseaux: 1, vsPuits: 0, vsFeu: 2, vsSablier: 0, vsVent: 1, vsAcanthe: 1, vsPie: 1, vsJoker: 0, occurrence: 5, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721851/card000010_fbjlwy.png" },
      { nom: "Sablier", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 0, vsFeu: 0, vsSablier: 2, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 7, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721376/card000007_esqtsq.png" },
      { nom: "Vent", vsPierre: 0, vsFeuille: 1, vsCiseaux: 1, vsPuits: 0, vsFeu: 0, vsSablier: 0, vsVent: 2, vsAcanthe: 1, vsPie: 1, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764722011/card0000011_jsd1m7.png" },
      { nom: "Acanthe", vsPierre: 1, vsFeuille: 1, vsCiseaux: 0, vsPuits: 1, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 2, vsPie: 1, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721732/card000008_orvnrp.png" },
      { nom: "Pie", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 1, vsFeu: 0, vsSablier: 1, vsVent: 0, vsAcanthe: 0, vsPie: 2, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721058/card000006_hpmmzl.png" },
      { nom: "Joker", vsPierre: 1, vsFeuille: 1, vsCiseaux: 1, vsPuits: 1, vsFeu: 1, vsSablier: 1, vsVent: 1, vsAcanthe: 1, vsPie: 1, vsJoker: 1, occurrence: 17, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764721516/card000009_bqra6a.png" }
    ];

    const bonusCardNames = ["Puits", "Feu", "Sablier", "Vent", "Acanthe", "Pie", "Joker"];

    function getRandomBonusCard() {
      const pool = cardsDatabase.filter(c => bonusCardNames.includes(c.nom));
      if (pool.length === 0) return null;
      const index = Math.floor(Math.random() * pool.length);
      return pool[index];
    }

    
    // Ã‰tat du mini-jeu
    let gameState = {
      isGameActive: false,
      currentTurn: 0,
      playerHasInitiative: false,
      deckJoueur: [],
      deckAdversaire: [],
      mainJoueur: [],
      mainAdversaire: [],
      carteJoueeJoueur: null,
      carteJoueeAdversaire: null,
      waitingForPlayerAction: false,
      actionType: null, // "draw", "play"
      isPaused: false // Jeu en pause pendant l'indicateur
    };
    
    // Dialogues pour chaque type de pion
    const dialogues = {
      green: {
        name: "Pion Vert",
        pages: [
          "Bonjour je suis le Pion Vert nÂ° 1 ! Je garde ce secteur de la ville.",
          "Tu ne passeras pas si facilement. PrÃ©pare-toi Ã  affronter ma dÃ©termination !",
          "Bon... peut-Ãªtre une autre fois. Je dois y aller maintenant !"
        ]
      },
      purple: {
        name: "Pion Violet",
        pages: [
          "Ah, nous nous rencontrons enfin. Je suis le Pion Violet.",
          "On m'a prÃ©venu de ta venue dans ces rues. Tu es courageux de venir jusqu'ici.",
          "Cette confrontation est terminÃ©e pour aujourd'hui. Ã€ bientÃ´t, voyageur."
        ]
      },
      default: {
        name: "Antagoniste",
        pages: [
          "Bonjour, Ã©tranger.",
          "Que fais-tu dans ce quartier ?"
        ]
      }
    };
 

    function init() {
      // CrÃ©er la scÃ¨ne
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      
      // CrÃ©er la camÃ©ra (vue en trois-quarts plongÃ©e avec face supÃ©rieure horizontale)
      camera = new THREE.PerspectiveCamera(
        50,
        1,
        0.1,
        1000
      );
      camera.position.set(0, 12, 10);
      camera.lookAt(0, 0, 0);
      
      // CrÃ©er le renderer
      const container = document.getElementById('container');
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(600, 600);
      container.insertBefore(renderer.domElement, container.firstChild);


      // === Charger la sprite-sheet du dÃ©tective ===
      const textureLoader = new THREE.TextureLoader();
      detectiveTexture = textureLoader.load('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764722295/detective001_ioa12y.png', (tex) => {
        // Pixel-art net
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;

        // On choisit une pose par dÃ©faut (ex : 3/4 face sud-est)
        setDetectiveFrame('SE');
      });

      
      // CrÃ©er la skysphere
      createSkysphere();
      
      // CrÃ©er le damier 15x15
      checkerboard = new THREE.Group();
      
      // GÃ©nÃ©rer le rÃ©seau routier
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // VÃ©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // DÃ©terminer si c'est une route ou un bÃ¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444 // Gris clair pour routes, gris foncÃ© pour bÃ¢timents
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }

      // Rotation initiale du damier Ã  45Â° pour la vue en diagonale
      checkerboard.rotation.y = Math.PI / 4;
      targetRotation = checkerboard.rotation.y;
      
      scene.add(checkerboard);

      // CrÃ©er tous les pions (dont le dÃ©tective)
      createAllPions();

      // DÃ©marrer le tour du joueur
      startPlayerTurn();

      // Placer les bonus collectables aprÃ¨s les pions
      createAllBonuses();

      // Mettre Ã  jour l'affichage des jauges
      updateGaugesDisplay();

      // Lancer la boucle de rendu
      animate();
    }
    

    function createSkysphere() {
      // CrÃ©er une sphÃ¨re inversÃ©e (texture Ã  l'intÃ©rieur)
      const geometry = new THREE.SphereGeometry(100, 64, 64);
      
      // Charger la texture
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764366928/uzralk_texture_for_3D_skysphere_video_game_texture_futuristic_i_ea3bf670-69cf-42b7-9daf-c4fd4040b193_d5nsmp.png');
      
      // CrÃ©er le matÃ©riau avec la texture Ã  l'intÃ©rieur
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.BackSide, // Rendre visible l'intÃ©rieur de la sphÃ¨re
        transparent: false
      });
      
      skysphere = new THREE.Mesh(geometry, material);
      
      // Rotation initiale pour aligner avec le damier
      // La rotation de 45Â° correspond Ã  l'orientation initiale du damier
      skysphere.rotation.y = Math.PI / 4; // 45 degrÃ©s
      
      scene.add(skysphere);
    }


    function setDetectiveFrame(direction) {
      if (!detectiveTexture) return;

      // Sprite-sheet 2x2 : chaque frame occupe 1/2 de la largeur et 1/2 de la hauteur
      const frameW = 0.5;
      const frameH = 0.5;

      detectiveTexture.repeat.set(frameW, frameH);

      // Attention : en UV, y = 0 est en bas de l'image
      // On suppose le layout suivant :
      //  haut-gauche : NE (3/4 dos nord-est)
      //  haut-droite : NW (3/4 dos nord-ouest)
      //  bas-gauche : SE (3/4 face sud-est)
      //  bas-droite : SW (3/4 face sud-ouest)

      switch (direction) {
        case 'NE': // haut-gauche
          detectiveTexture.offset.set(0.0, 0.5);
          break;
        case 'NW': // haut-droite
          detectiveTexture.offset.set(0.5, 0.5);
          break;
        case 'SE': // bas-gauche
          detectiveTexture.offset.set(0.0, 0.0);
          break;
        case 'SW': // bas-droite
          detectiveTexture.offset.set(0.5, 0.0);
          break;
      }

      detectiveTexture.needsUpdate = true;
    }


    function updateDetectiveAnimation(time) {
      if (!detectiveTexture) return;

      if (time === undefined) time = 0;

      // passer Ã  la frame suivante ?
      if (time - lastDetectiveFrameTime > detectiveFrameDuration) {
        lastDetectiveFrameTime = time;
        detectiveFrameIndex = (detectiveFrameIndex + 1) % detectiveIdleSequence.length;

        const dir = detectiveIdleSequence[detectiveFrameIndex];
        setDetectiveFrame(dir);  // rÃ©utilise ta logique NE / NW / SE / SW
      }
    }


    function generateCityMap() {
      // CrÃ©er une grille initiale remplie de bÃ¢timents (false)
      const map = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      // Liste de toutes les positions des routes
      const roadCells = [];
      
      // Commencer au centre
      let currentRow = Math.floor(boardSize / 2);
      let currentCol = Math.floor(boardSize / 2);
      map[currentRow][currentCol] = true;
      roadCells.push({ row: currentRow, col: currentCol });
      
      const numSegments = 18 + Math.floor(Math.random() * 8); // 18-25 tronÃ§ons pour mieux couvrir
      
      for (let segment = 0; segment < numSegments; segment++) {
        // Choisir un point de dÃ©part parmi les routes existantes
        const startPoint = roadCells[Math.floor(Math.random() * roadCells.length)];
        currentRow = startPoint.row;
        currentCol = startPoint.col;
        
        // Choisir une direction alÃ©atoire (0: haut, 1: droite, 2: bas, 3: gauche)
        const direction = Math.floor(Math.random() * 4);
        // Longueur du tronÃ§on (minimum 3 cases, maximum 6 cases)
        const length = 3 + Math.floor(Math.random() * 4);
        
        let deltaRow = 0, deltaCol = 0;
        if (direction === 0) deltaRow = -1; // Haut
        else if (direction === 1) deltaCol = 1; // Droite
        else if (direction === 2) deltaRow = 1; // Bas
        else if (direction === 3) deltaCol = -1; // Gauche
        
        // VÃ©rifier si le tronÃ§on peut Ãªtre crÃ©Ã© sans violer les rÃ¨gles
        let canCreate = true;
        let tempRow = currentRow;
        let tempCol = currentCol;
        const newCells = [];
        
        for (let step = 0; step < length; step++) {
          tempRow += deltaRow;
          tempCol += deltaCol;
          
          // VÃ©rifier les limites
          if (tempRow < 0 || tempRow >= boardSize || 
              tempCol < 0 || tempCol >= boardSize) {
            canCreate = false;
            break;
          }
          
          newCells.push({ row: tempRow, col: tempCol });
          
          // VÃ©rifier qu'il n'y a pas de tronÃ§ons parallÃ¨les collÃ©s
          if (!canCreate) break;
          
          // Pour un tronÃ§on horizontal (direction gauche/droite)
          if (direction === 1 || direction === 3) {
            // VÃ©rifier au-dessus et en-dessous
            if (tempRow > 0 && map[tempRow - 1][tempCol] && !map[tempRow][tempCol]) {
              // VÃ©rifier si c'est un tronÃ§on horizontal parallÃ¨le
              if ((tempCol > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow - 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempRow < boardSize - 1 && map[tempRow + 1][tempCol] && !map[tempRow][tempCol]) {
              // VÃ©rifier si c'est un tronÃ§on horizontal parallÃ¨le
              if ((tempCol > 0 && map[tempRow + 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
          
          // Pour un tronÃ§on vertical (direction haut/bas)
          if (direction === 0 || direction === 2) {
            // VÃ©rifier Ã  gauche et Ã  droite
            if (tempCol > 0 && map[tempRow][tempCol - 1] && !map[tempRow][tempCol]) {
              // VÃ©rifier si c'est un tronÃ§on vertical parallÃ¨le
              if ((tempRow > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol - 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempCol < boardSize - 1 && map[tempRow][tempCol + 1] && !map[tempRow][tempCol]) {
              // VÃ©rifier si c'est un tronÃ§on vertical parallÃ¨le
              if ((tempRow > 0 && map[tempRow - 1][tempCol + 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
        }
        
        // CrÃ©er le tronÃ§on seulement s'il est valide
        if (canCreate) {
          for (const cell of newCells) {
            if (!map[cell.row][cell.col]) {
              map[cell.row][cell.col] = true;
              roadCells.push(cell);
            }
          }
        }
      }
      
      // S'assurer que chaque zone 4x4 contient au moins une route
      for (let blockRow = 0; blockRow < boardSize - 3; blockRow += 4) {
        for (let blockCol = 0; blockCol < boardSize - 3; blockCol += 4) {
          let hasRoad = false;
          
          // VÃ©rifier si ce bloc 4x4 a au moins une route
          for (let r = blockRow; r < Math.min(blockRow + 4, boardSize); r++) {
            for (let c = blockCol; c < Math.min(blockCol + 4, boardSize); c++) {
              if (map[r][c]) {
                hasRoad = true;
                break;
              }
            }
            if (hasRoad) break;
          }
          
          // Si pas de route, en crÃ©er une connectÃ©e au rÃ©seau le plus proche
          if (!hasRoad && roadCells.length > 0) {
            // Trouver la route la plus proche de ce bloc
            let closestRoad = null;
            let minDistance = Infinity;
            
            const blockCenterRow = blockRow + 1.5;
            const blockCenterCol = blockCol + 1.5;
            
            for (const road of roadCells) {
              const dist = Math.abs(road.row - blockCenterRow) + Math.abs(road.col - blockCenterCol);
              if (dist < minDistance) {
                minDistance = dist;
                closestRoad = road;
              }
            }
            
            // CrÃ©er un chemin depuis la route la plus proche vers ce bloc
            if (closestRoad) {
              let pathRow = closestRoad.row;
              let pathCol = closestRoad.col;
              const targetRow = Math.floor(blockCenterRow);
              const targetCol = Math.floor(blockCenterCol);
              
              // CrÃ©er un chemin simple (Manhattan)
              while (pathRow !== targetRow || pathCol !== targetCol) {
                if (pathRow < targetRow) pathRow++;
                else if (pathRow > targetRow) pathRow--;
                else if (pathCol < targetCol) pathCol++;
                else if (pathCol > targetCol) pathCol--;
                
                if (pathRow >= 0 && pathRow < boardSize && pathCol >= 0 && pathCol < boardSize) {
                  if (!map[pathRow][pathCol]) {
                    map[pathRow][pathCol] = true;
                    roadCells.push({ row: pathRow, col: pathCol });
                  }
                }
              }
            }
          }
        }
      }
      
      return map;
    }
    
    function addLandmarks(map) {
      // Ajouter des lieux dits : 8 rouges, 1 bleu, 1 vert
      const landmarks = [];
      const landmarkTypes = [
        { color: 0x8B0000, count: 8, type: 'red' },   // 8 cases rouge sombre
        { color: 0x00008B, count: 1, type: 'blue' },  // 1 case bleu sombre
        { color: 0x006400, count: 1, type: 'green' }  // 1 case vert sombre
      ];
      
      // CrÃ©er un tableau pour marquer les positions des landmarks
      const landmarkMap = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      for (const landmarkType of landmarkTypes) {
        for (let i = 0; i < landmarkType.count; i++) {
          let placed = false;
          let attempts = 0;
          
          while (!placed && attempts < 500) {
            attempts++;
            const row = Math.floor(Math.random() * boardSize);
            const col = Math.floor(Math.random() * boardSize);
            
            // VÃ©rifier que c'est un bÃ¢timent (pas une route)
            if (map[row][col] || landmarkMap[row][col]) continue;
            
            // VÃ©rifier qu'il y a au moins une route adjacente
            let hasAdjacentRoad = false;
            if (row > 0 && map[row - 1][col]) hasAdjacentRoad = true;
            if (row < boardSize - 1 && map[row + 1][col]) hasAdjacentRoad = true;
            if (col > 0 && map[row][col - 1]) hasAdjacentRoad = true;
            if (col < boardSize - 1 && map[row][col + 1]) hasAdjacentRoad = true;
            
            if (!hasAdjacentRoad) continue;
            
            // VÃ©rifier qu'aucun autre landmark n'est adjacent
            let hasAdjacentLandmark = false;
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                  if (landmarkMap[nr][nc]) {
                    hasAdjacentLandmark = true;
                    break;
                  }
                }
              }
              if (hasAdjacentLandmark) break;
            }
            
            if (hasAdjacentLandmark) continue;
            
            // Placer le landmark
            landmarkMap[row][col] = true;
            landmarks.push({ row, col, color: landmarkType.color, type: landmarkType.type });
            placed = true;
          }
        }
      }
      
      return landmarks;
    }
    
    function createBuilding(type, size) {
      // CrÃ©er un groupe pour l'immeuble
      const building = new THREE.Group();
      
      // DÃ©terminer la couleur pastel et le nombre d'Ã©tages selon le type
      let color, floors;
      if (type === 'red') {
        color = 0xffb3ba; // Rose pastel
        floors = Math.random() < 0.5 ? 2 : 3; // 2 ou 3 Ã©tages
      } else if (type === 'blue') {
        color = 0xbae1ff; // Bleu pastel
        floors = 3;
      } else { // green
        color = 0xbaffc9; // Vert pastel
        floors = 3;
      }
      
      // CrÃ©er les Ã©tages (cubes empilÃ©s)
      for (let i = 0; i < floors; i++) {
        const floorGeometry = new THREE.BoxGeometry(size, size, size);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: color });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Positionner chaque Ã©tage
        floor.position.y = 0.15 + size / 2 + i * size;
        
        // Ajouter des arÃªtes pour mieux voir la structure
        const edges = new THREE.EdgesGeometry(floorGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        floor.add(wireframe);
        
        building.add(floor);
      }
      
      // Ajouter un toit biseautÃ© sur le dernier Ã©tage
      const roofHeight = size * 0.3;
      const roofGeometry = createBeveledRoofGeometry(size, roofHeight);
      const roofMaterial = new THREE.MeshBasicMaterial({ color: color });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      
      // Positionner le toit au-dessus du dernier Ã©tage
      roof.position.y = 0.15 + floors * size;
      
      // Ajouter des arÃªtes au toit
      const roofEdges = new THREE.EdgesGeometry(roofGeometry);
      const roofLineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
      const roofWireframe = new THREE.LineSegments(roofEdges, roofLineMaterial);
      roof.add(roofWireframe);
      
      building.add(roof);
      
      return building;
    }
    
    function createBeveledRoofGeometry(size, height) {
      // CrÃ©er un toit biseautÃ© (pyramide tronquÃ©e sur une face)
      const shape = new THREE.Shape();
      
      // Base du toit (carrÃ©)
      const halfSize = size / 2;
      
      // CrÃ©er une gÃ©omÃ©trie personnalisÃ©e pour le toit biseautÃ©
      const geometry = new THREE.BufferGeometry();
      
      // DÃ©finir les sommets
      const vertices = new Float32Array([
        // Base (y = 0)
        -halfSize, 0, -halfSize,  // 0
        halfSize, 0, -halfSize,   // 1
        halfSize, 0, halfSize,    // 2
        -halfSize, 0, halfSize,   // 3
        
        // Sommet biseautÃ© (y = height, dÃ©calÃ© vers l'avant)
        -halfSize * 0.3, height, -halfSize * 0.3,  // 4
        halfSize * 0.3, height, -halfSize * 0.3,   // 5
        halfSize * 0.3, height, halfSize * 0.3,    // 6
        -halfSize * 0.3, height, halfSize * 0.3    // 7
      ]);
      
      // DÃ©finir les faces (triangles)
      const indices = [
        // Base
        0, 2, 1,  0, 3, 2,
        
        // CÃ´tÃ©s
        0, 1, 5,  0, 5, 4,  // Face avant
        1, 2, 6,  1, 6, 5,  // Face droite
        2, 3, 7,  2, 7, 6,  // Face arriÃ¨re
        3, 0, 4,  3, 4, 7,  // Face gauche
        
        // Sommet
        4, 5, 6,  4, 6, 7
      ];
      
      geometry.setIndex(indices);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    

    function getRoadExtremities() {
      const extremities = [];

      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          if (!cityMap[row][col]) continue; // pas une route

          let neighbors = 0;

          if (row > 0 && cityMap[row - 1][col]) neighbors++;
          if (row < boardSize - 1 && cityMap[row + 1][col]) neighbors++;
          if (col > 0 && cityMap[row][col - 1]) neighbors++;
          if (col < boardSize - 1 && cityMap[row][col + 1]) neighbors++;

          // une seule route voisine => extrÃ©mitÃ© (cul-de-sac)
          if (neighbors === 1) {
            extremities.push({ row, col });
          }
        }
      }

      return extremities;
    }



    function updateGaugesDisplay() {
      // Mettre Ã  jour l'affichage des jauges
      document.getElementById('heures-value').textContent = heuresEnquete;
      document.getElementById('confrontation-value').textContent = pointsConfrontation;
      
      const alignementElement = document.getElementById('alignement-value');
      alignementElement.textContent = pointsAlignement > 0 ? `+${pointsAlignement}` : pointsAlignement;
      
      // Changer la couleur selon le signe
      alignementElement.classList.remove('positive', 'negative');
      if (pointsAlignement > 0) {
        alignementElement.classList.add('positive');
      } else if (pointsAlignement < 0) {
        alignementElement.classList.add('negative');
      }
    }
    
    // ===== FONCTIONS DU MINI-JEU DE CARTES =====
    
    function startCardGame() {
      console.log("=== DÃ‰BUT DU MINI-JEU ===");
      gameState.isGameActive = true;
      gameState.currentTurn = 0;
      
      // Rendre le tableau de cartes visible
      const cardsContainer = document.getElementById('cards-game-container');
      cardsContainer.classList.add('visible');
      
      // Tirer l'initiative au hasard
      gameState.playerHasInitiative = Math.random() < 0.5;
      console.log(`Initiative: ${gameState.playerHasInitiative ? "Joueur" : "Adversaire"}`);
      
      // PrÃ©parer les decks
      preparerDecks();
      
      // DÃ©marrer le premier tour
      setTimeout(() => {
        if (gameState.playerHasInitiative) {
          demarrerTourJoueurInitiative();
        } else {
          demarrerTourAdversaireInitiative();
        }
      }, 1000);
    }
    
    function preparerDecks() {
      // Deck du joueur : 3 Pierre, 3 Feuille, 3 Ciseaux + cartes collectÃ©es
      gameState.deckJoueur = [];
      for (let i = 0; i < 3; i++) {
        gameState.deckJoueur.push(cardsDatabase[0]); // Pierre
        gameState.deckJoueur.push(cardsDatabase[1]); // Feuille
        gameState.deckJoueur.push(cardsDatabase[2]); // Ciseaux
      }
      
      // Ajouter les cartes collectÃ©es
      gameState.deckJoueur = gameState.deckJoueur.concat(cartesCollectees);
      
      // MÃ©langer le deck
      shuffleDeck(gameState.deckJoueur);
      
      // Deck adversaire : cartes bonus selon l'inventaire du joueur
      gameState.deckAdversaire = [];
      const nbCartesBonus = Math.max(0, cartesCollectees.length - 1);
      
      for (let i = 0; i < nbCartesBonus; i++) {
        const carte = tirerCarteAleatoire(cardsDatabase);
        gameState.deckAdversaire.push(carte);
      }
      
      console.log(`Deck Joueur: ${gameState.deckJoueur.length} cartes`);
      console.log(`Deck Adversaire: ${gameState.deckAdversaire.length} cartes`);
    }
    
    function shuffleDeck(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }
    
    function tirerCarteAleatoire(source) {
      // Tirer selon l'occurrence
      const totalOccurrence = source.reduce((sum, card) => sum + card.occurrence, 0);
      let random = Math.random() * totalOccurrence;
      
      for (const card of source) {
        random -= card.occurrence;
        if (random <= 0) {
          return card;
        }
      }
      
      return source[0];
    }
    
    function demarrerTourJoueurInitiative() {
      gameState.currentTurn++;
      console.log(`=== TOUR ${gameState.currentTurn} - Joueur a l'initiative ===`);
      
      clearCardsDisplay();
      
      // Afficher le message de dÃ©but de tour
      const dialogueText = document.getElementById('dialogue-text');
      dialogueText.textContent = `Tour de Jeu nÂ°${gameState.currentTurn}, Initiative : Joueur`;
      
      // Le joueur commence avec une main vide - il va tirer 3 cartes
      gameState.mainJoueur = [];
      
      // Distribuer 3 cartes Ã  l'adversaire
      const cartesDeBase = [cardsDatabase[0], cardsDatabase[1], cardsDatabase[2]];
      gameState.mainAdversaire = [];
      for (let i = 0; i < 3; i++) {
        // Tirer depuis le deck adversaire s'il a des cartes, sinon depuis les cartes de base
        if (gameState.deckAdversaire.length > 0) {
          const carte = gameState.deckAdversaire.pop();
          gameState.mainAdversaire.push(carte);
        } else {
          // Si le deck adversaire est vide, utiliser des cartes de base
          const carte = cartesDeBase[Math.floor(Math.random() * 3)];
          gameState.mainAdversaire.push(carte);
        }
      }
      
      afficherCartes();
      afficherDeckCentral(); // Afficher le deck car le joueur va devoir cliquer dessus
      
      // Afficher le message d'instruction aprÃ¨s un court dÃ©lai
      setTimeout(() => {
        dialogueText.textContent = "Cliquez sur le deck central pour tirer une carte au hasard et composer votre Main.";
      }, 1500);
      
      // Afficher l'indicateur pour la carte centrale
      setTimeout(() => {
        afficherIndicateurZone('center');
      }, 2000);
      
      // Inviter le joueur Ã  tirer sa premiÃ¨re carte
      gameState.waitingForPlayerAction = true;
      gameState.actionType = "draw";
      console.log("Cliquez sur le deck pour tirer vos cartes (1/3)");
    }
    
    function demarrerTourAdversaireInitiative() {
      gameState.currentTurn++;
      console.log(`=== TOUR ${gameState.currentTurn} - Adversaire a l'initiative ===`);
      
      clearCardsDisplay();
      
      // Afficher le message de dÃ©but de tour
      const dialogueText = document.getElementById('dialogue-text');
      dialogueText.textContent = `Tour de Jeu nÂ°${gameState.currentTurn}, Initiative : Adversaire`;
      
      // Le joueur commence avec une main vide - il va tirer 3 cartes
      gameState.mainJoueur = [];
      
      // Distribuer 3 cartes Ã  l'adversaire
      const cartesDeBase = [cardsDatabase[0], cardsDatabase[1], cardsDatabase[2]];
      gameState.mainAdversaire = [];
      for (let i = 0; i < 3; i++) {
        // Tirer depuis le deck adversaire s'il a des cartes, sinon depuis les cartes de base
        if (gameState.deckAdversaire.length > 0) {
          const carte = gameState.deckAdversaire.pop();
          gameState.mainAdversaire.push(carte);
        } else {
          // Si le deck adversaire est vide, utiliser des cartes de base
          const carte = cartesDeBase[Math.floor(Math.random() * 3)];
          gameState.mainAdversaire.push(carte);
        }
      }
      
      afficherCartes();
      
      // L'adversaire joue une carte
      setTimeout(() => {
        dialogueText.textContent = "L'adversaire engage une carte...";
        
        setTimeout(() => {
          adversaireJoueCarte();
          
          // Afficher le deck car le joueur va devoir cliquer dessus
          afficherDeckCentral();
          
          // Message d'instruction
          setTimeout(() => {
            dialogueText.textContent = "Cliquez sur le deck central pour tirer une carte au hasard et composer votre Main.";
          }, 500);
          
          // Afficher l'indicateur pour la carte centrale
          setTimeout(() => {
            afficherIndicateurZone('center');
          }, 1000);
          
          // Inviter le joueur Ã  tirer sa premiÃ¨re carte
          gameState.waitingForPlayerAction = true;
          gameState.actionType = "draw";
          console.log("Cliquez sur le deck pour tirer vos cartes (1/3)");
        }, 1000);
      }, 1500);
    }
    
    function retirerCarteDuDeck(deck, carte) {
      const index = deck.findIndex(c => c.nom === carte.nom);
      if (index !== -1) {
        deck.splice(index, 1);
      }
    }
    
    function afficherCartes() {
      // Afficher main du joueur
      for (let i = 0; i < 3; i++) {
        const cardEl = document.getElementById(`card-player-${i + 1}`);
        if (cardEl) {
          if (i < gameState.mainJoueur.length) {
            cardEl.style.backgroundImage = `url('${gameState.mainJoueur[i].img}')`;
            cardEl.style.backgroundColor = '';
            cardEl.style.visibility = 'visible';
          } else {
            // Laisser l'emplacement vide
            cardEl.style.backgroundImage = 'none';
            cardEl.style.backgroundColor = 'rgba(50, 50, 50, 0.3)';
            cardEl.style.visibility = 'visible';
          }
        }
      }
      
      // Afficher main de l'adversaire
      for (let i = 0; i < 3; i++) {
        const cardEl = document.getElementById(`card-npc-${i + 1}`);
        if (cardEl) {
          if (i < gameState.mainAdversaire.length) {
            cardEl.style.backgroundImage = `url('${gameState.mainAdversaire[i].img}')`;
            cardEl.style.backgroundColor = '';
            cardEl.style.visibility = 'visible';
          } else {
            // Laisser l'emplacement vide
            cardEl.style.backgroundImage = 'none';
            cardEl.style.backgroundColor = 'rgba(50, 50, 50, 0.3)';
            cardEl.style.visibility = 'visible';
          }
        }
      }
      
      // Ne PAS afficher la carte centrale ici - elle sera gÃ©rÃ©e sÃ©parÃ©ment
      
      // Afficher les cartes jouÃ©es si elles existent
      if (gameState.carteJoueeJoueur) {
        const cardEl = document.getElementById('card-player-played');
        cardEl.style.backgroundImage = `url('${gameState.carteJoueeJoueur.img}')`;
        cardEl.style.backgroundColor = '';
        cardEl.style.visibility = 'visible';
      }
      
      if (gameState.carteJoueeAdversaire) {
        const cardEl = document.getElementById('card-npc-played');
        cardEl.style.backgroundImage = `url('${gameState.carteJoueeAdversaire.img}')`;
        cardEl.style.backgroundColor = '';
        cardEl.style.visibility = 'visible';
      }
    }
    
    function afficherDeckCentral() {
      const centerCard = document.getElementById('card-center');
      if (centerCard) {
        centerCard.style.visibility = 'visible';
        centerCard.style.backgroundImage = 'url("https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg")';
        centerCard.style.backgroundColor = '';
      }
    }
    
    function masquerDeckCentral() {
      const centerCard = document.getElementById('card-center');
      if (centerCard) {
        centerCard.style.visibility = 'hidden';
        centerCard.style.backgroundImage = 'none';
        centerCard.style.backgroundColor = '';
      }
    }
    
    function clearCardsDisplay() {
      // Cacher toutes les cartes sauf le deck central
      for (let i = 1; i <= 3; i++) {
        const playerCard = document.getElementById(`card-player-${i}`);
        const npcCard = document.getElementById(`card-npc-${i}`);
        if (playerCard) {
          playerCard.style.visibility = 'hidden';
          playerCard.style.backgroundImage = 'none';
          playerCard.style.backgroundColor = '';
        }
        if (npcCard) {
          npcCard.style.visibility = 'hidden';
          npcCard.style.backgroundImage = 'none';
          npcCard.style.backgroundColor = '';
        }
      }
      
      const playerPlayed = document.getElementById('card-player-played');
      const npcPlayed = document.getElementById('card-npc-played');
      const centerCard = document.getElementById('card-center');
      
      if (playerPlayed) {
        playerPlayed.style.visibility = 'hidden';
        playerPlayed.style.backgroundImage = 'none';
        playerPlayed.style.backgroundColor = '';
      }
      if (npcPlayed) {
        npcPlayed.style.visibility = 'hidden';
        npcPlayed.style.backgroundImage = 'none';
        npcPlayed.style.backgroundColor = '';
      }
      if (centerCard) {
        centerCard.style.visibility = 'hidden';
        centerCard.style.backgroundImage = 'none';
        centerCard.style.backgroundColor = '';
      }
      
      gameState.carteJoueeJoueur = null;
      gameState.carteJoueeAdversaire = null;
    }
    
    function joueurTireCarte() {
      if (gameState.deckJoueur.length > 0 && gameState.mainJoueur.length < 3) {
        const carte = gameState.deckJoueur.pop();
        gameState.mainJoueur.push(carte);
        afficherCartes();
        
        const nbCartes = gameState.mainJoueur.length;
        console.log(`Carte tirÃ©e (${nbCartes}/3)`);
        
        // Si le joueur a tirÃ© 3 cartes, il peut maintenant choisir
        if (nbCartes >= 3) {
          // Masquer le deck aprÃ¨s avoir tirÃ© toutes les cartes
          masquerDeckCentral();
          
          gameState.actionType = "play";
          
          // Afficher l'indicateur pour la main du joueur
          setTimeout(() => {
            afficherIndicateurZone('player-hand');
          }, 500);
          
           // Message d'instruction
          setTimeout(() => {
            const dialogueText = document.getElementById('dialogue-text');
            dialogueText.textContent = "Choisissez l'une de vos trois cartes pour attaquer";
          }, 500);         // console.log("Choisissez une carte Ã  jouer");
        } else {
          // Continuer Ã  tirer
          console.log(`Cliquez sur le deck pour tirer vos cartes (${nbCartes + 1}/3)`);
          
          // RÃ©afficher l'indicateur pour la carte centrale
          setTimeout(() => {
            afficherIndicateurZone('center');
          }, 500);
        }
      }
    }
    
    function joueurJoueCarte(index) {
      if (index < gameState.mainJoueur.length) {
        gameState.carteJoueeJoueur = gameState.mainJoueur[index];
        gameState.mainJoueur.splice(index, 1);
        // Si cette carte provient de l'inventaire (bonus collectÃ©s), on la retire dÃ©finitivement de l'inventaire
        const invIndex = cartesCollectees.indexOf(gameState.carteJoueeJoueur);
        if (invIndex !== -1) {
          cartesCollectees.splice(invIndex, 1);
        }

        afficherCartes();
        
        gameState.waitingForPlayerAction = false;
        
        // Si adversaire n'a pas encore jouÃ©, il joue maintenant
        if (!gameState.carteJoueeAdversaire) {
          setTimeout(() => {
            adversaireJoueCarte();
            resoudreTour();
          }, 500);
        } else {
          // Sinon rÃ©soudre directement
          resoudreTour();
        }
      }
    }
    
    function adversaireJoueCarte() {
      console.log("Adversaire joue une carte...");
      
      if (gameState.mainAdversaire.length === 0) {
        console.error("Adversaire n'a pas de cartes!");
        return;
      }
      
      // StratÃ©gie simple : essayer de gagner ou faire Ã©galitÃ©
      let bestIndex = 0;
      
      if (gameState.carteJoueeJoueur) {
        // Adversaire rÃ©pond Ã  la carte du joueur
        let bestScore = -1;
        for (let i = 0; i < gameState.mainAdversaire.length; i++) {
          const score = evaluerCarte(gameState.mainAdversaire[i], gameState.carteJoueeJoueur);
          if (score > bestScore) {
            bestScore = score;
            bestIndex = i;
          }
        }
        console.log(`Adversaire choisit la carte ${bestIndex + 1} (score: ${bestScore})`);
      } else {
        // Adversaire joue en premier, choix alÃ©atoire
        bestIndex = Math.floor(Math.random() * gameState.mainAdversaire.length);
        console.log(`Adversaire choisit la carte ${bestIndex + 1} (alÃ©atoire)`);
      }
      
      gameState.carteJoueeAdversaire = gameState.mainAdversaire[bestIndex];
      gameState.mainAdversaire.splice(bestIndex, 1);
      
      console.log(`Adversaire joue: ${gameState.carteJoueeAdversaire.nom}`);
      
      afficherCartes();
    }
    
    function evaluerCarte(carteAttaquant, carteDefenseur) {
      const nomDefenseur = carteDefenseur.nom;
      const key = `vs${nomDefenseur}`;
      return carteAttaquant[key] || 0;
    }
    
    function resoudreTour() {
      if (!gameState.carteJoueeJoueur || !gameState.carteJoueeAdversaire) return;
      
      const scoreJoueur = evaluerCarte(gameState.carteJoueeJoueur, gameState.carteJoueeAdversaire);
      const scoreAdversaire = evaluerCarte(gameState.carteJoueeAdversaire, gameState.carteJoueeJoueur);
      
      let resultat = "";
      let gainPerte = 0;
      
      // VICTOIRE si le joueur a un meilleur score
      if (scoreJoueur > scoreAdversaire) {
        resultat = "VICTOIRE";
        gainPerte = gameState.carteJoueeJoueur.occurrence;
        heuresEnquete += gainPerte;
        console.log(`Joueur gagne avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      } 
      // DÃ‰FAITE si l'adversaire a un meilleur score
      else if (scoreAdversaire > scoreJoueur) {
        resultat = "DÃ‰FAITE";
        gainPerte = -gameState.carteJoueeAdversaire.occurrence;
        heuresEnquete += gainPerte;
        console.log(`Joueur perd avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      } 
      // Ã‰GALITÃ‰ si scores identiques
      else {
        resultat = "Ã‰GALITÃ‰";
        console.log(`Ã‰galitÃ© avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      }
      
      // Ajouter au total de la confrontation
      pointsGagnesConfrontation += gainPerte;
      
      console.log(`${resultat} - ${gainPerte > 0 ? '+' : ''}${gainPerte} Heures d'EnquÃªte`);
      
      // Afficher le rÃ©sultat avec animation
      const resultDisplay = document.getElementById('result-display');
      resultDisplay.textContent = resultat;
      resultDisplay.className = 'show';
      
      // Couleur selon le rÃ©sultat
      if (resultat === "VICTOIRE") {
        resultDisplay.style.color = '#2ecc71';
      } else if (resultat === "DÃ‰FAITE") {
        resultDisplay.style.color = '#e74c3c';
      } else {
        resultDisplay.style.color = '#f39c12';
      }
      
      updateGaugesDisplay();
      
      // Afficher les points gagnÃ©s/perdus pour ce tour
      if (gainPerte !== 0) {
        setTimeout(() => {
          afficherPointsGagnes(gainPerte);
        }, 1500);
      }
      
      // Passer au tour suivant ou terminer
      setTimeout(() => {
        resultDisplay.classList.remove('show');
        
        setTimeout(() => {
          if (gameState.currentTurn >= 2) {
            terminerMiniJeu();
          } else {
            // Tour suivant avec initiative inversÃ©e
            if (gameState.playerHasInitiative) {
              demarrerTourAdversaireInitiative();
            } else {
              demarrerTourJoueurInitiative();
            }
          }
        }, 300);
      }, 2000);
    }
    
    function terminerMiniJeu() {
      console.log("=== FIN DU MINI-JEU ===");
      gameState.isGameActive = false;
      clearCardsDisplay();
      
      // Afficher le total des points gagnÃ©s/perdus pendant la confrontation
      if (pointsGagnesConfrontation !== 0) {
        setTimeout(() => {
          afficherPointsGagnes(pointsGagnesConfrontation, true);
        }, 500);
      }
      
      // Masquer le bouton "Next Page" et afficher le bouton "Refermer"
      setTimeout(() => {
        const nextPageBtn = document.getElementById('next-page-btn');
        const closeBtn = document.getElementById('close-confrontation-btn');
        
        nextPageBtn.style.display = 'none';
        nextPageBtn.style.pointerEvents = 'none';
        
        closeBtn.classList.add('visible');
        
        console.log("Cliquez sur 'Refermer' pour terminer la confrontation");
      }, pointsGagnesConfrontation !== 0 ? 2500 : 0);
    }
    
    function reinitialiserMiniJeu() {
      console.log("RÃ©initialisation du mini-jeu de cartes");
      
      // Masquer le tableau de cartes
      const cardsContainer = document.getElementById('cards-game-container');
      cardsContainer.classList.remove('visible');
      
      // Masquer l'affichage du rÃ©sultat
      const resultDisplay = document.getElementById('result-display');
      resultDisplay.classList.remove('show');
      resultDisplay.textContent = '';
      
      // RÃ©afficher le bouton "Next Page" et masquer le bouton "Refermer"
      const nextPageBtn = document.getElementById('next-page-btn');
      const closeBtn = document.getElementById('close-confrontation-btn');
      
      nextPageBtn.style.display = 'inline-block';
      nextPageBtn.style.pointerEvents = 'auto';
      
      closeBtn.classList.remove('visible');
      
      // RÃ©initialiser l'Ã©tat du jeu
      gameState.isGameActive = false;
      gameState.currentTurn = 0;
      gameState.playerHasInitiative = false;
      gameState.deckJoueur = [];
      gameState.deckAdversaire = [];
      gameState.mainJoueur = [];
      gameState.mainAdversaire = [];
      gameState.carteJoueeJoueur = null;
      gameState.carteJoueeAdversaire = null;
      gameState.waitingForPlayerAction = false;
      gameState.actionType = null;
      
      // RÃ©initialiser la page de dialogue
      currentDialoguePage = 0;
      
      // Effacer complÃ¨tement l'affichage des cartes
      clearCardsDisplay();
      
      // Nettoyer la case centrale
      const centerCard = document.getElementById('card-center');
      centerCard.textContent = '';
      centerCard.style.fontSize = '';
      centerCard.style.color = '';
      centerCard.style.display = '';
      centerCard.style.visibility = 'hidden';
      centerCard.style.backgroundImage = 'none';
      centerCard.style.backgroundColor = '';
      
      console.log("Mini-jeu rÃ©initialisÃ© et prÃªt pour la prochaine confrontation");
    }
    
    function afficherIndicateurZone(zone) {
      gameState.isPaused = true; // Mettre le jeu en pause
      
      const indicator = document.getElementById('click-indicator');
      const confrontationPanel = document.getElementById('confrontation-panel');
      
      let indicatorStyle = {};
      
      if (zone === 'center') {
        // Indicateur sur la carte centrale
        const centerCard = document.getElementById('card-center');
        const cardRect = centerCard.getBoundingClientRect();
        const panelRect = confrontationPanel.getBoundingClientRect();
        
        indicatorStyle = {
          left: (cardRect.left - panelRect.left - 5) + 'px',
          top: (cardRect.top - panelRect.top - 5) + 'px',
          width: (cardRect.width + 10) + 'px',
          height: (cardRect.height + 10) + 'px'
        };
      } else if (zone === 'player-hand') {
        // Indicateur sur toute la ligne du haut (main du joueur)
        const firstCard = document.getElementById('card-player-1');
        const lastCard = document.getElementById('card-player-3');
        const firstRect = firstCard.getBoundingClientRect();
        const lastRect = lastCard.getBoundingClientRect();
        const panelRect = confrontationPanel.getBoundingClientRect();
        
        indicatorStyle = {
          left: (firstRect.left - panelRect.left - 5) + 'px',
          top: (firstRect.top - panelRect.top - 5) + 'px',
          width: (lastRect.right - firstRect.left + 10) + 'px',
          height: (firstRect.height + 10) + 'px'
        };
      }
      
      // Appliquer les styles
      Object.assign(indicator.style, indicatorStyle);
      indicator.classList.add('show');
      
      // Masquer aprÃ¨s 800ms et reprendre le jeu
      setTimeout(() => {
        indicator.classList.remove('show');
        gameState.isPaused = false; // Reprendre le jeu
      }, 800);
    }
    
    function afficherPointsGagnes(points, isTotal = false) {
      const pointsDisplay = document.getElementById('points-display');
      
      console.log(`Affichage des points: ${points} (Total: ${isTotal})`);
      
      // Texte selon le contexte
      let texte = '';
      if (isTotal) {
        texte = points > 0 ? `+${points} Heures d'EnquÃªte` : `${points} Heures d'EnquÃªte`;
      } else {
        texte = points > 0 ? `+${points}` : `${points}`;
      }
      
      pointsDisplay.textContent = texte;
      
      // Couleur selon gain ou perte
      if (points > 0) {
        pointsDisplay.style.color = '#2ecc71'; // Vert pour gain
      } else if (points < 0) {
        pointsDisplay.style.color = '#e74c3c'; // Rouge pour perte
      } else {
        pointsDisplay.style.color = '#f39c12'; // Orange pour zÃ©ro
      }
      
      // S'assurer que l'Ã©lÃ©ment est visible
      pointsDisplay.style.display = 'block';
      
      // RÃ©initialiser l'animation en enlevant puis rajoutant la classe
      pointsDisplay.classList.remove('show');
      
      // Force un reflow pour redÃ©marrer l'animation
      void pointsDisplay.offsetWidth;
      
      // Afficher avec animation
      pointsDisplay.classList.add('show');
      
      console.log("Points affichÃ©s!");
      
      // Masquer aprÃ¨s 2 secondes
      setTimeout(() => {
        pointsDisplay.classList.remove('show');
        setTimeout(() => {
          pointsDisplay.style.display = 'none';
        }, 300);
      }, 2000);
    }


    function showTrapOverlay() {
      const overlay = document.getElementById('bonus-overlay');
      const img = document.getElementById('bonus-overlay-image');
      const text = document.getElementById('bonus-overlay-text');
      const alert = document.getElementById('bonus-alert');

      // PiÃ¨ge : pas dâ€™image de carte, juste un gros texte
      img.style.display = 'none';
      text.textContent = 'PIÃˆGE !';
      text.style.display = 'block';

      overlay.style.display = 'flex';

      alert.textContent = "3 Heures d'EnquÃªte retirÃ©es !";
      alert.style.display = 'block';
    }

    function showCardOverlay(card) {
      const overlay = document.getElementById('bonus-overlay');
      const img = document.getElementById('bonus-overlay-image');
      const text = document.getElementById('bonus-overlay-text');
      const alert = document.getElementById('bonus-alert');

      // Carte bonus : on affiche lâ€™image
      text.style.display = 'none';
      img.src = card.img;
      img.style.display = 'block';

      overlay.style.display = 'flex';

      alert.textContent = `Carte obtenue : ${card.nom}`;
      alert.style.display = 'block';
    }

    function hideBonusOverlay() {
      const overlay = document.getElementById('bonus-overlay');
      const img = document.getElementById('bonus-overlay-image');
      const text = document.getElementById('bonus-overlay-text');
      const alert = document.getElementById('bonus-alert');

      overlay.style.display = 'none';
      img.style.display = 'none';
      text.style.display = 'none';
      alert.style.display = 'none';
    }


    
    function calculateAccessibleCells(fromRow, fromCol, range) {
      // Calculer les cases accessibles depuis une position donnÃ©e avec un range
      const accessible = [];
      const visited = new Set();
      const queue = [{ row: fromRow, col: fromCol, distance: 0 }];
      
      visited.add(`${fromRow}-${fromCol}`);
      
      // Ajouter la case de dÃ©part comme accessible (distance 0)
      accessible.push({ row: fromRow, col: fromCol, distance: 0 });
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.distance >= range) continue;
        
        // VÃ©rifier les 4 directions (haut, bas, gauche, droite)
        const directions = [
          { dr: -1, dc: 0 },  // Haut
          { dr: 1, dc: 0 },   // Bas
          { dr: 0, dc: -1 },  // Gauche
          { dr: 0, dc: 1 }    // Droite
        ];
        
        for (const dir of directions) {
          const newRow = current.row + dir.dr;
          const newCol = current.col + dir.dc;
          const key = `${newRow}-${newCol}`;
          
          // VÃ©rifier les limites et si la case est une route
          if (newRow >= 0 && newRow < boardSize && 
              newCol >= 0 && newCol < boardSize && 
              cityMap[newRow][newCol] && 
              !visited.has(key)) {
            
            visited.add(key);
            
            // VÃ©rifier si la case n'est pas occupÃ©e par un autre pion
            const isOccupied = pions.some(p => 
              p !== redPion && p.userData.row === newRow && p.userData.col === newCol
            );
            
            if (!isOccupied) {
              accessible.push({ row: newRow, col: newCol, distance: current.distance + 1 });
              queue.push({ row: newRow, col: newCol, distance: current.distance + 1 });
            }
          }
        }
      }
      
      return accessible;
    }


    function getBonusAt(row, col) {
      return bonusItems.find(b => b.userData.row === row && b.userData.col === col) || null;
    }


    function highlightAccessibleCells() {
      // Retirer la surbrillance de toutes les cases
      clearHighlights();
      
      if (!redPion) return;
      
      // Calculer les cases accessibles
      accessibleCells = calculateAccessibleCells(
        redPion.userData.row, 
        redPion.userData.col, 
        moveRange
      );
      
      // Mettre en surbrillance les cases accessibles
      accessibleCells.forEach(cell => {
        const key = `${cell.row}-${cell.col}`;
        const square = squareMeshes[key];
        if (square) {
          square.material.color.setHex(0xffff99); // Jaune clair
        }
      });
    }
    
    function clearHighlights() {
      // Restaurer la couleur originale de toutes les cases
      for (const key in squareMeshes) {
        const square = squareMeshes[key];
        square.material.color.setHex(square.userData.originalColor);
      }
    }
    
    function startPlayerTurn() {
      isPlayerTurn = true;
      
      // MÃ©moriser la position de dÃ©part du tour
      if (redPion) {
        startTurnPosition = { row: redPion.userData.row, col: redPion.userData.col };
      }
      
      highlightAccessibleCells();
      updateGaugesDisplay();
      
      console.log("=== Tour du joueur ===");
      console.log(`Heures d'EnquÃªte: ${heuresEnquete}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log("DÃ©placez-vous dans les cases surlignÃ©es, puis appuyez sur la flamme");
    }
    

    function endPlayerTurn() {
      isPlayerTurn = false;
      clearHighlights();

      // Calculer la distance parcourue pendant ce tour
      if (redPion) {
        const distanceTraveled = Math.abs(redPion.userData.row - startTurnPosition.row) + 
                                  Math.abs(redPion.userData.col - startTurnPosition.col);
        
        // Soustraire les heures d'enquÃªte
        heuresEnquete -= distanceTraveled;
        console.log(`Distance parcourue: ${distanceTraveled} cases`);
        console.log(`Heures d'EnquÃªte restantes: ${heuresEnquete}`);
        
        // Mettre Ã  jour l'affichage
        updateGaugesDisplay();
        
        // VÃ©rifier si le joueur a perdu (plus d'heures d'enquÃªte)
        if (heuresEnquete <= 0) {
          gameOver();
          return;
        }
      }

      // AprÃ¨s le dÃ©placement, on gÃ¨re d'abord un Ã©ventuel bonus sur la case
      processEndOfTurnBonusAndConfrontation();
    }


    function processEndOfTurnBonusAndConfrontation() {
      if (!redPion) {
        // sÃ©curitÃ©
        setTimeout(() => {
          aiTurn();
        }, 500);
        return;
      }

      const currentRow = redPion.userData.row;
      const currentCol = redPion.userData.col;

      const bonus = getBonusAt(currentRow, currentCol);
      const hasEnemyAdjacent = isEnemyAdjacentToRedPion();

      if (bonus) {
        collectBonus(bonus, hasEnemyAdjacent);
      } else {
        // Pas de bonus : on retrouve le comportement prÃ©cÃ©dent
        if (hasEnemyAdjacent) {
          console.log("Pion adverse adjacent dÃ©tectÃ© - Confrontation immÃ©diate");
          openConfrontation();
        } else {
          console.log("Tour de l'adversaire");
          setTimeout(() => {
            aiTurn();
          }, 500);
        }
      }
    }


    function collectBonus(bonus, hasEnemyAdjacent) {
      // A) retirer dÃ©finitivement le bonus
      const index = bonusItems.indexOf(bonus);
      if (index !== -1) {
        bonusItems.splice(index, 1);
      }
      checkerboard.remove(bonus);

      // PiÃ¨ge ou bonus ?
      const isTrap = !!bonus.userData.isTrap;

      if (isTrap) {
        // C-a) PiÃ¨ge
        console.log("Bonus : PIÃˆGE !");

        // Retirer 3 heures d'enquÃªte
        heuresEnquete -= 3;
        if (heuresEnquete < 0) heuresEnquete = 0;
        updateGaugesDisplay();

        showTrapOverlay();

        // AprÃ¨s < 2s, on masque et on enchaÃ®ne
        setTimeout(() => {
          hideBonusOverlay();

          // Si plus d'heures aprÃ¨s le piÃ¨ge -> Game Over
          if (heuresEnquete <= 0) {
            gameOver();
            return;
          }

          if (hasEnemyAdjacent) {
            console.log("Confrontation retardÃ©e aprÃ¨s piÃ¨ge");
            openConfrontation();
          } else {
            console.log("Tour de l'adversaire aprÃ¨s piÃ¨ge");
            setTimeout(() => {
              aiTurn();
            }, 500);
          }
        }, 1800);

      } else {
        // C-b) Bonus de carte
        const card = getRandomBonusCard();
        if (!card) {
          console.warn("Aucune carte bonus disponible");
          if (hasEnemyAdjacent) {
            openConfrontation();
          } else {
            setTimeout(() => {
              aiTurn();
            }, 500);
          }
          return;
        }

        console.log(`Bonus : carte obtenue -> ${card.nom}`);

        // Ajouter la carte Ã  l'inventaire du joueur pour cette partie
        cartesCollectees.push(card);

        showCardOverlay(card);

        setTimeout(() => {
          hideBonusOverlay();

          if (hasEnemyAdjacent) {
            console.log("Confrontation retardÃ©e aprÃ¨s obtention de carte bonus");
            openConfrontation();
          } else {
            console.log("Tour de l'adversaire aprÃ¨s obtention de carte bonus");
            setTimeout(() => {
              aiTurn();
            }, 500);
          }
        }, 1800);
      }
    }


    function gameOver() {
      console.log("=== VOUS AVEZ PERDU ===");
      console.log("Vos Heures d'EnquÃªte sont Ã©puisÃ©es!");
      alert("VOUS AVEZ PERDU\n\nVos Heures d'EnquÃªte sont Ã©puisÃ©es!\n\nCliquez sur 'Recommencer' pour rejouer.");
      isPlayerTurn = false;
    }
    
    function isEnemyAdjacentToRedPion() {
      if (!redPion) return false;
      
      const redRow = redPion.userData.row;
      const redCol = redPion.userData.col;
      
      // VÃ©rifier les 4 cases adjacentes (haut, bas, gauche, droite)
      const adjacentPositions = [
        { row: redRow - 1, col: redCol },     // Haut
        { row: redRow + 1, col: redCol },     // Bas
        { row: redRow, col: redCol - 1 },     // Gauche
        { row: redRow, col: redCol + 1 }      // Droite
      ];
      
      // VÃ©rifier si un pion adverse (pas le rouge) est sur une case adjacente
      for (const pos of adjacentPositions) {
        const enemyOnCell = pions.find(p => 
          p !== redPion && 
          p.userData.row === pos.row && 
          p.userData.col === pos.col
        );
        
        if (enemyOnCell) {
          console.log("Pion adverse adjacent dÃ©tectÃ© - Confrontation dÃ©clenchÃ©e!");
          confrontedPion = enemyOnCell; // MÃ©moriser le pion confrontÃ©
          return true;
        }
      }
      
      return false;
    }
    
    function openConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.add('active');
      
      // RÃ©initialiser le compteur de points de la confrontation
      pointsGagnesConfrontation = 0;
      
      // IncrÃ©menter le compteur de confrontations
      confrontationCount++;
      
      // Calculer les points d'alignement Ã  ajouter/soustraire (2, 4, 6, 8, 10, ...)
      const alignmentChange = confrontationCount * 2;
      
      // DÃ©terminer le type de pion confrontÃ©
      let dialogueType = 'default';
      let pionColor = 'default';
      
      if (confrontedPion) {
        // Identifier le type basÃ© sur l'index dans le tableau pionTypes
        const pionIndex = pions.indexOf(confrontedPion);
        if (pionIndex === 0) {
          dialogueType = 'default'; // Pion rouge (ne devrait pas arriver)
        } else if (pionIndex >= 1 && pionIndex <= 5) {
          dialogueType = 'green'; // Pions verts (indices 1-5)
          pionColor = 'green';
          // Confrontation avec un pion vert : on AJOUTE des points d'alignement
          pointsAlignement += alignmentChange;
          console.log(`+${alignmentChange} Points d'Alignement (confrontation avec pion vert)`);
        } else {
          dialogueType = 'purple'; // Pions violets (indices 6-8)
          pionColor = 'purple';
          // Confrontation avec un pion violet : on SOUSTRAIT des points d'alignement
          pointsAlignement -= alignmentChange;
          console.log(`-${alignmentChange} Points d'Alignement (confrontation avec pion violet)`);
        }
      }
      
      // Calculer les points de confrontation initiaux (6 de base)
      pointsConfrontation = 6;
      
      // Appliquer les bonus/malus selon l'alignement
      if (pointsAlignement > 0) {
        // Alignement positif : bonus avec violets, malus avec verts
        if (pionColor === 'green') {
          pointsConfrontation -= 3;
        } else if (pionColor === 'purple') {
          pointsConfrontation += 3;
        }
      } else if (pointsAlignement < 0) {
        // Alignement nÃ©gatif : bonus avec verts, malus avec violets
        if (pionColor === 'green') {
          pointsConfrontation += 3;
        } else if (pionColor === 'purple') {
          pointsConfrontation -= 3;
        }
      }
      
      console.log("=== CONFRONTATION ===");
      console.log(`Confrontation nÂ°${confrontationCount}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log(`Points de Confrontation: ${pointsConfrontation}`);
      
      // Mettre Ã  jour l'affichage
      updateGaugesDisplay();
      
      // RÃ©initialiser Ã  la premiÃ¨re page
      currentDialoguePage = 0;
      updateDialogue(dialogueType);
      
      console.log("Phase Confrontation dÃ©clenchÃ©e");
    }
    
    function updateDialogue(dialogueType) {
      const dialogue = dialogues[dialogueType] || dialogues.default;
      const nameElement = document.getElementById('character-name');
      const textElement = document.getElementById('dialogue-text');
      const nextBtn = document.getElementById('next-page-btn');
      
      // Mettre Ã  jour le nom
      nameElement.textContent = dialogue.name;
      
      // Mettre Ã  jour le texte de la page actuelle
      if (currentDialoguePage < dialogue.pages.length) {
        textElement.textContent = dialogue.pages[currentDialoguePage];
      }
      
      // Cacher le bouton "Next Page" si on est Ã  la derniÃ¨re page
      if (currentDialoguePage >= dialogue.pages.length - 1) {
        nextBtn.style.display = 'none';
        // DÃ©marrer le mini-jeu quand le dialogue est terminÃ©
        if (!gameState.isGameActive) {
          setTimeout(() => {
            startCardGame();
          }, 500);
        }
      } else {
        nextBtn.style.display = 'inline-block';
      }
      
      // Stocker le type de dialogue pour le bouton Next Page
      nextBtn.dataset.dialogueType = dialogueType;
    }
    
    function closeConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.remove('active');
      console.log("Phase Confrontation terminÃ©e");
      
      // Regagner 5 heures d'enquÃªte aprÃ¨s une confrontation
      heuresEnquete += 5;
      console.log(`+5 Heures d'EnquÃªte (rÃ©compense de confrontation)`);
      console.log(`Heures d'EnquÃªte: ${heuresEnquete}`);
      
      // Replacer le pion confrontÃ© ailleurs sur l'Ã©chiquier
      if (confrontedPion) {
        relocateConfrontedPion(confrontedPion);
        confrontedPion = null; // RÃ©initialiser
      }
      
      // RÃ©initialiser les points de confrontation Ã  zÃ©ro
      pointsConfrontation = 0;
      console.log(`Points de Confrontation rÃ©initialisÃ©s: ${pointsConfrontation}`);
      
      // RÃ©initialiser le mini-jeu de cartes
      reinitialiserMiniJeu();
      
      // Mettre Ã  jour l'affichage
      updateGaugesDisplay();
      
      // Continuer le tour de l'adversaire aprÃ¨s la fermeture
      setTimeout(() => {
        aiTurn();
      }, 500);
    }
    
    function relocateConfrontedPion(pion) {
      // Trouver une case route libre (non occupÃ©e par un autre pion)
      const freeCells = roadPositions.filter(road => {
        // VÃ©rifier qu'aucun pion n'occupe cette case
        const isOccupied = pions.some(p => 
          p.userData.row === road.row && p.userData.col === road.col
        );
        return !isOccupied;
      });
      
      if (freeCells.length > 0) {
        // Choisir une case alÃ©atoire parmi les cases libres
        const newCell = freeCells[Math.floor(Math.random() * freeCells.length)];
        movePion(pion, newCell.row, newCell.col);
        console.log(`Pion confrontÃ© replacÃ© Ã  la position (${newCell.row}, ${newCell.col})`);
      } else {
        console.log("Aucune case libre disponible pour replacer le pion confrontÃ©");
      }
    }
    
    function aiTurn() {
      // L'IA choisit un pion au hasard (pas le rouge) et le dÃ©place
      const aiPions = pions.filter(p => p !== redPion);
      if (aiPions.length === 0) {
        startPlayerTurn();
        return;
      }
      
      const selectedPion = aiPions[Math.floor(Math.random() * aiPions.length)];
      const aiAccessible = calculateAccessibleCells(
        selectedPion.userData.row,
        selectedPion.userData.col,
        moveRange
      );
      
      if (aiAccessible.length > 0) {
        const targetCell = aiAccessible[Math.floor(Math.random() * aiAccessible.length)];
        movePion(selectedPion, targetCell.row, targetCell.col);
      }
      
      // Retour au tour du joueur
      setTimeout(() => {
        startPlayerTurn();
      }, 500);
    }
    
    function movePion(pion, toRow, toCol) {
      // DÃ©placer un pion vers une nouvelle case
      pion.userData.row = toRow;
      pion.userData.col = toCol;
      
      const x = (toCol - (boardSize - 1) / 2) * squareSize;
      const z = (toRow - (boardSize - 1) / 2) * squareSize;
      
      pion.userData.baseX = x;
      pion.userData.baseZ = z;
      
      const pionHeight = pion.scale.y;
      pion.position.set(x, pionHeight / 2, z);
    }
    
    function createPionTexture(color) {
      // CrÃ©er une texture pour un pion d'une couleur donnÃ©e
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      
      // Fond transparent
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner un pion simple (cercle + base)
      // Positionner pour que le bas de l'image soit le point d'ancrage
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(64, 50, 40, 0, Math.PI * 2);
      ctx.fill();
      
      // Base plus foncÃ©e
      const darkColor = shadeColor(color, -30);
      ctx.fillStyle = darkColor;
      ctx.fillRect(50, 90, 28, 60);
      ctx.beginPath();
      ctx.ellipse(64, 150, 25, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      
      return new THREE.CanvasTexture(canvas);
    }


    function createBonusTexture(color) {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Petit paquet rectangulaire
      const x = 24;
      const y = 40;
      const w = 80;
      const h = 48;

      // Corps du paquet
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      // Bordure un peu plus sombre
      ctx.strokeStyle = '#cc6600';
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, w, h);

      // Ruban vertical
      ctx.fillStyle = '#ffcc66';
      ctx.fillRect(x + w / 2 - 4, y, 8, h);

      // Ruban horizontal
      ctx.fillRect(x, y + h / 2 - 4, w, 8);

      return new THREE.CanvasTexture(canvas);
    }


    function shadeColor(color, percent) {
      // Fonction pour assombrir une couleur
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
        (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
        .toString(16).slice(1);
    }
    

    function createAllPions() {
      // Supprimer tous les anciens pions
      pions.forEach(p => checkerboard.remove(p));
      pions = [];
      redPion = null;
      
      // CrÃ©er un ensemble pour suivre les cases occupÃ©es
      const occupiedPositions = new Set();
      
      // S'assurer qu'il y a assez de routes pour tous les pions
      if (roadPositions.length < 9) {
        console.error("Pas assez de routes pour placer tous les pions!");
        return;
      }
      
      // CrÃ©er chaque type de pion
      pionTypes.forEach((type, typeIndex) => {
        for (let i = 0; i < type.count; i++) {
          // Trouver une position alÃ©atoire libre sur une route
          let roadIndex, position, posKey;
          let attempts = 0;
          do {
            roadIndex = Math.floor(Math.random() * roadPositions.length);
            position = roadPositions[roadIndex];
            posKey = `${position.row}-${position.col}`;
            attempts++;
            if (attempts > 1000) {
              console.error("Impossible de trouver une position libre!");
              return;
            }
          } while (occupiedPositions.has(posKey));
          
          occupiedPositions.add(posKey);
          
          // === Choix du matÃ©riau ===
          let material;

          // Le tout premier pion du premier type (ex-pion rouge) devient le dÃ©tective
          if (typeIndex === 0 && i === 0 && detectiveTexture) {
            material = new THREE.SpriteMaterial({
              map: detectiveTexture,
              transparent: true
            });
          } else {
            // Tous les autres pions : pions ronds classiques
            const texture = createPionTexture(type.color);
            material = new THREE.SpriteMaterial({ 
              map: texture,
              transparent: true
            });
          }

          
          // CrÃ©er le pion (sprite)
          const pion = new THREE.Sprite(material);
          const pionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const pionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pion.scale.set(pionScale, pionHeight, 1);
          
          // Positionner le pion sur la case
          const x = (position.col - (boardSize - 1) / 2) * squareSize;
          const z = (position.row - (boardSize - 1) / 2) * squareSize;
          pion.position.set(x, pionHeight / 2, z);
          
          // Stocker les coordonnÃ©es du pion et sa position de base
          pion.userData = { 
            row: position.row, 
            col: position.col,
            baseX: x,
            baseZ: z
          };
          
          checkerboard.add(pion);
          pions.push(pion);
          
          // Garder une rÃ©fÃ©rence au pion rouge (qui est dÃ©sormais le dÃ©tective)
          if (typeIndex === 0 && i === 0) {
            redPion = pion;
          }
        }
      });
    }


    function createAllBonuses() {
      // Supprimer les anciens bonus (si existants)
      bonusItems.forEach(b => checkerboard.remove(b));
      bonusItems = [];

      if (!redPion) return;
      if (!roadPositions || roadPositions.length === 0) return;

      const bonusCount = 9;

      // Case du dÃ©tective Ã  Ã©viter
      const redKey = `${redPion.userData.row}-${redPion.userData.col}`;

      // RepÃ©rer les extrÃ©mitÃ©s de routes
      const extremities = getRoadExtremities();
      const extremitySet = new Set(extremities.map(c => `${c.row}-${c.col}`));

      // Construire une liste pondÃ©rÃ©e de cases routes (extrÃ©mitÃ©s plus frÃ©quentes)
      const weightedCells = [];
      roadPositions.forEach(cell => {
        const key = `${cell.row}-${cell.col}`;
        if (key === redKey) return; // pas de bonus sous le dÃ©tective

        const weight = extremitySet.has(key) ? 4 : 1; // extrÃ©mitÃ©s 4x plus probables
        for (let i = 0; i < weight; i++) {
          weightedCells.push(cell);
        }
      });

      if (weightedCells.length === 0) return;

      // Nombre maximum de cases uniques possibles
      const uniqueKeys = new Set(weightedCells.map(c => `${c.row}-${c.col}`));
      const maxPossible = uniqueKeys.size;
      const finalBonusCount = Math.min(bonusCount, maxPossible);

      const occupiedBonusPositions = new Set();
      const bonusTexture = createBonusTexture('#ff8800');

      let attempts = 0;
      while (bonusItems.length < finalBonusCount && attempts < 2000 && weightedCells.length > 0) {
        attempts++;
        const index = Math.floor(Math.random() * weightedCells.length);
        const cell = weightedCells[index];
        const key = `${cell.row}-${cell.col}`;

        if (occupiedBonusPositions.has(key)) continue;

        // CrÃ©er le sprite du bonus
        const material = new THREE.SpriteMaterial({
          map: bonusTexture,
          transparent: true
        });

        const bonus = new THREE.Sprite(material);

        // Plus petit que les pions
        const bonusScale = squareSize * 0.5;
        const bonusHeight = squareSize * 0.6;
        bonus.scale.set(bonusScale, bonusHeight, 1);

        const x = (cell.col - (boardSize - 1) / 2) * squareSize;
        const z = (cell.row - (boardSize - 1) / 2) * squareSize;

        // On le pose comme les pions (ancrÃ© au sol)
        bonus.position.set(x, bonusHeight / 2, z);

        bonus.userData = {
          row: cell.row,
          col: cell.col
        };

        checkerboard.add(bonus);
        bonusItems.push(bonus);
        occupiedBonusPositions.add(key);
      }

      // Marquer tous les bonus par dÃ©faut comme non-piÃ¨ges
      bonusItems.forEach(b => {
        b.userData.isTrap = false;
      });

      // Choisir au hasard 4 bonus (ou moins si < 4) pour devenir des piÃ¨ges
      if (bonusItems.length > 0) {
        const indices = bonusItems.map((_, i) => i);

        // MÃ©lange des indices (Fisherâ€“Yates)
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        const trapCount = Math.min(4, bonusItems.length);
        for (let k = 0; k < trapCount; k++) {
          const idx = indices[k];
          bonusItems[idx].userData.isTrap = true;
        }

        console.log(`PiÃ¨ges assignÃ©s : ${trapCount}`);
      }

      console.log(`Bonus placÃ©s : ${bonusItems.length}`);
    }


    function animate(time) {
      // time est fourni automatiquement par requestAnimationFrame
      requestAnimationFrame(animate);

      // Met Ã  jour l'animation du dÃ©tective (idle)
      updateDetectiveAnimation(time || 0);

      // Animation de rotation progressive
      if (isRotating) {
        const diff = targetRotation - checkerboard.rotation.y;
        if (Math.abs(diff) > 0.01) {
          checkerboard.rotation.y += diff * 0.1;
          
          // Faire pivoter la skysphere en synchronisation avec le damier
          if (skysphere) {
            skysphere.rotation.y = checkerboard.rotation.y + Math.PI / 4; // +45Â° pour l'alignement initial
          }
          
          // Si on est zoomÃ©, mettre Ã  jour la position de la camÃ©ra pour suivre le pion rouge
          if (isZoomed && redPion) {
            const redPionWorldPos = new THREE.Vector3();
            redPion.getWorldPosition(redPionWorldPos);
            
            targetCameraPos = {
              x: redPionWorldPos.x,
              y: 3,
              z: redPionWorldPos.z + 2.5
            };
            targetCameraLookAt = {
              x: redPionWorldPos.x,
              y: 0,
              z: redPionWorldPos.z
            };
            
            camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
            camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          }
        } else {
          checkerboard.rotation.y = targetRotation;
          if (skysphere) {
            skysphere.rotation.y = targetRotation + Math.PI / 4;
          }
          isRotating = false;
        }
      }
      
      // Animation de zoom progressive
      if (isZooming) {
        const posXDiff = targetCameraPos.x - camera.position.x;
        const posYDiff = targetCameraPos.y - camera.position.y;
        const posZDiff = targetCameraPos.z - camera.position.z;
        
        if (Math.abs(posXDiff) > 0.01 || Math.abs(posYDiff) > 0.01 || Math.abs(posZDiff) > 0.01) {
          camera.position.x += posXDiff * 0.1;
          camera.position.y += posYDiff * 0.1;
          camera.position.z += posZDiff * 0.1;
          
          // Mettre Ã  jour la cible de la camÃ©ra
          const lookAtX = targetCameraLookAt.x;
          const lookAtY = targetCameraLookAt.y;
          const lookAtZ = targetCameraLookAt.z;
          camera.lookAt(lookAtX, lookAtY, lookAtZ);
          
          // Mettre Ã  jour la taille des pions progressivement
          const zoomProgress = isZoomed ? 
            1 - Math.abs(posYDiff) / (12 - 3) : 
            Math.abs(posYDiff) / (12 - 3);
          const pionScale = squareSize * (0.8 + zoomProgress * 1.2);
          const pionHeight = squareSize * (1.1 + zoomProgress * 1.4);
          
          pions.forEach(p => {
            p.scale.set(pionScale, pionHeight, 1);
            // Maintenir le pion ancrÃ© au centre de sa case
            p.position.y = pionHeight / 2;
          });
        } else {
          camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
          camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          isZooming = false;
          
          // Fixer la taille finale des pions
          const finalPionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const finalPionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pions.forEach(p => {
            p.scale.set(finalPionScale, finalPionHeight, 1);
            // Maintenir le pion ancrÃ© au centre de sa case
            p.position.y = finalPionHeight / 2;
          });
        }
      }
      
      renderer.render(scene, camera);
    }

    
    // Gestionnaires des boutons Rotate
    document.getElementById('rotateRightBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation += Math.PI / 2; // +90 degrÃ©s
        currentRotationStep = (currentRotationStep + 1) % 4;
        updateDirectionMappings();
      }
    });
    
    document.getElementById('rotateLeftBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation -= Math.PI / 2; // -90 degrÃ©s
        currentRotationStep = (currentRotationStep - 1 + 4) % 4;
        updateDirectionMappings();
      }
    });
    
    document.getElementById('zoomBtn').addEventListener('click', function() {
      if (!isZooming && redPion) {
        isZooming = true;
        isZoomed = !isZoomed;
        
        if (isZoomed) {
          // Vue rapprochÃ©e : centrer sur le pion rouge
          const redPionWorldPos = new THREE.Vector3();
          redPion.getWorldPosition(redPionWorldPos);
          
          // CamÃ©ra plus proche et plus horizontale
          targetCameraPos = {
            x: redPionWorldPos.x,
            y: 3,  // Beaucoup plus bas qu'avant (Ã©tait 12)
            z: redPionWorldPos.z + 2.5  // Plus proche
          };
          targetCameraLookAt = {
            x: redPionWorldPos.x,
            y: 0,
            z: redPionWorldPos.z
          };
          
          this.textContent = 'UnZoom';
        } else {
          // Vue gÃ©nÃ©rale
          targetCameraPos = { x: 0, y: 12, z: 10 };
          targetCameraLookAt = { x: 0, y: 0, z: 0 };
          
          this.textContent = 'Zoom';
        }
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', function() {
      // RÃ©initialiser les jauges de points
      heuresEnquete = 15;
      pointsConfrontation = 0;
      pointsAlignement = 0;
      confrontationCount = 0;
      currentRotationStep = 0;
      cartesCollectees = []; // <-- ici
      
      console.log("=== JEU RÃ‰INITIALISÃ‰ ===");
      console.log(`Heures d'EnquÃªte: ${heuresEnquete}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log(`Confrontations: ${confrontationCount}`);
      
      // Mettre Ã  jour l'affichage
      updateGaugesDisplay();
      
      // RÃ©gÃ©nÃ©rer le rÃ©seau routier
      checkerboard.clear();
      
      // RÃ©gÃ©nÃ©rer le damier avec un nouveau plan
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // VÃ©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // DÃ©terminer si c'est une route ou un bÃ¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }
      
      // CrÃ©er les nouveaux pions
      createAllPions();
 
      // Placer les bonus collectables
      createAllBonuses();

      // RÃ©initialiser le zoom si on Ã©tait zoomÃ©
      if (isZoomed) {
        isZoomed = false;
        isZooming = false;
        camera.position.set(0, 12, 10);
        camera.lookAt(0, 0, 0);
        targetCameraPos = { x: 0, y: 12, z: 10 };
        targetCameraLookAt = { x: 0, y: 0, z: 0 };
        document.getElementById('zoomBtn').textContent = 'Zoom';
      }
      
      // RedÃ©marrer le tour du joueur
      startPlayerTurn();
    });
    
    // Gestionnaires pour la croix directionnelle
    document.getElementById('dpad-UR').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('UR');
      }
    });
    
    document.getElementById('dpad-BR').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('BR');
      }
    });
    
    document.getElementById('dpad-BL').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('BL');
      }
    });
    
    document.getElementById('dpad-UL').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('UL');
      }
    });
    
    // Fonctions de dÃ©placement absolues (relatives Ã  la grille)
    function moveUp() {
      movePlayerOneStep(-1, 0); // row--
    }
    
    function moveRight() {
      movePlayerOneStep(0, 1); // col++
    }
    
    function moveDown() {
      movePlayerOneStep(1, 0); // row++
    }
    
    function moveLeft() {
      movePlayerOneStep(0, -1); // col--
    }
    
    // Mapping des boutons aux fonctions selon la rotation
    let directionMappings = {
      'UR': moveUp,
      'BR': moveRight,
      'BL': moveDown,
      'UL': moveLeft
    };
    
    function updateDirectionMappings() {
      // RÃ©affecter les fonctions selon la rotation actuelle
      // currentRotationStep: 0=0Â°, 1=90Â°, 2=180Â°, 3=270Â°
      
      switch(currentRotationStep) {
        case 0: // 0Â° - orientation initiale
          directionMappings = {
            'UR': moveUp,
            'BR': moveRight,
            'BL': moveDown,
            'UL': moveLeft
          };
          break;
        case 1: // 90Â° rotation droite
          directionMappings = {
            'UR': moveRight,
            'BR': moveDown,
            'BL': moveLeft,
            'UL': moveUp
          };
          break;
        case 2: // 180Â°
          directionMappings = {
            'UR': moveDown,
            'BR': moveLeft,
            'BL': moveUp,
            'UL': moveRight
          };
          break;
        case 3: // 270Â° (ou -90Â°)
          directionMappings = {
            'UR': moveLeft,
            'BR': moveUp,
            'BL': moveRight,
            'UL': moveDown
          };
          break;
      }
      
      console.log(`Direction mappings updated for rotation step ${currentRotationStep}`);
    }
    
    function executeDirection(buttonId) {
      const directionFunction = directionMappings[buttonId];
      if (directionFunction) {
        directionFunction();
      }
    }
    
    function movePlayerOneStep(deltaRow, deltaCol) {
      if (!redPion || !isPlayerTurn) return;
      
      // Calculer la case cible (une seule case de distance)
      const targetRow = redPion.userData.row + deltaRow;
      const targetCol = redPion.userData.col + deltaCol;
      
      // VÃ©rifier si la case cible est dans les cases accessibles
      const isAccessible = accessibleCells.some(cell => 
        cell.row === targetRow && cell.col === targetCol
      );
      
      if (isAccessible) {
        movePion(redPion, targetRow, targetCol);
        console.log("Pion dÃ©placÃ© - Continuez ou appuyez sur la flamme pour terminer votre tour");
      } else {
        console.log("Case non accessible");
      }
    }
    
    document.getElementById('dpad-center').addEventListener('click', function() {
      console.log('Action: Flamme - Fin du tour du joueur');
      // Terminer le tour du joueur
      if (isPlayerTurn) {
        endPlayerTurn();
      }
    });
    
    // Gestionnaire pour le bouton de fermeture de la confrontation
    document.getElementById('close-confrontation-btn').addEventListener('click', function() {
      closeConfrontation();
    });
    
    // Gestionnaire pour le bouton Next Page
    document.getElementById('next-page-btn').addEventListener('click', function() {
      currentDialoguePage++;
      const dialogueType = this.dataset.dialogueType || 'default';
      updateDialogue(dialogueType);
    });
    
    // Gestionnaires pour les cartes
    document.getElementById('card-center').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "draw" && !gameState.isPaused) {
        joueurTireCarte();
      }
    });
    
    document.getElementById('card-player-1').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(0);
      }
    });
    
    document.getElementById('card-player-2').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(1);
      }
    });
    
    document.getElementById('card-player-3').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(2);
      }
    });
    
    init();
  </script>
</body>
</html>