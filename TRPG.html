<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube 3D</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      position: relative;
    }
    
    #container {
      width: 600px;
      height: 600px;
      background-color: #ffffff;
      border: 2px solid #ccc;
      margin-bottom: 20px;
      position: relative;
    }
    
    #controls {
      display: flex;
      gap: 20px;
    }
    
    button {
      padding: 15px 30px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:active {
      background-color: #3d8b40;
    }
    
    /* Croix directionnelle */
    #dpad-container {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 140px;
      height: 140px;
    }
    
    .dpad-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: #555;
      border: 2px solid #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      transition: background-color 0.2s, transform 0.1s;
      transform: rotate(0deg);
      user-select: none;
    }
    
    .dpad-button:hover {
      background-color: #666;
    }
    
    .dpad-button:active {
      background-color: #777;
      transform: rotate(0deg) scale(0.95);
    }
    
    .dpad-button span {
      transform: rotate(0deg);
      display: block;
    }
    
    #dpad-UR {
      top: 7%;
      left: 7%;
      transform: translate(0%, 0%) rotate(0deg);
    }
    
    #dpad-BR {
      top: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-UL {
      bottom: 7%;
      left: 7%;
      transform: translateX(0%, 0%)  rotate(0deg);
    }
    
    #dpad-BL {
      bottom: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      background-color: #d35400;
      border-color: #a04000;
    }
    
    #dpad-center:hover {
      background-color: #e67e22;
    }
    
    #dpad-center:active {
      background-color: #ca6f1e;
      transform: translate(-50%, -50%) rotate(45deg) scale(0.95);
    }
    
    /* Compteurs de jauges */
    #gauges-display {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }
    
    .gauge {
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      padding: 6px 12px;
      min-width: 140px;
    }
    
    .gauge-label {
      font-size: 10px;
      font-weight: bold;
      color: #aaaaaa;
      margin: 0 0 3px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .gauge-value {
      font-size: 18px;
      font-weight: bold;
      margin: 0;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
    }
    
    #heures-value {
      color: #3498db;
    }
    
    #confrontation-value {
      color: #e74c3c;
    }
    
    #alignement-value {
      color: #f39c12;
    }
    
    #alignement-value.positive {
      color: #9b59b6;
    }
    
    #alignement-value.negative {
      color: #27ae60;
    }
    
    /* Volet de confrontation */
    #confrontation-panel {
      position: fixed;
      top: 0;
      right: -100%;
      width: 100%;
      height: 100%;
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453079/D_bureau_b2b5gx.png');
      background-size: cover;
      background-position: center;
      background-color: #2c3e50;
      transition: right 0.5s ease-in-out;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-end;
    }
    
    #confrontation-panel.active {
      right: 0;
    }
    
    /* Images des personnages */
    .character-container {
      position: absolute;
      bottom: 5%;
      height: 70%;
      display: flex;
      align-items: flex-end;
      z-index: 1001;
    }
    
    #antagonist-image {
      left: 0;
      max-height: 100%;
      object-fit: contain;
    }
    
    #player-image {
      right: 0;
      max-height: 100%;
      object-fit: contain;
    }
    
    .character-image {
      max-height: 75%;
      height: auto;
      filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.5));
    }
    
    /* Bloc de dialogue */
    #dialogue-container {
      position: relative;
      width: 100%;
      height: 25%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 20px;
      z-index: 1002;
    }
    
    #character-name-box {
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #ffffff;
      border-radius: 8px;
      padding: 8px 20px;
      margin-bottom: -2px;
      margin-left: 20px;
      z-index: 1003;
    }
    
    #character-name {
      font-size: 18px;
      font-weight: bold;
      color: white;
      text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
      margin: 0;
    }
    
    #dialogue-box {
      background-color: rgba(20, 20, 40, 0.85);
      border: 3px solid #444;
      border-radius: 12px;
      padding: 25px 30px;
      width: 100%;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
    }
    
    #dialogue-text {
      color: white;
      font-size: 20px;
      line-height: 1.6;
      margin: 0 0 15px 0;
      flex-grow: 1;
    }
    
    #dialogue-controls {
      display: flex;
      justify-content: flex-end;
      gap: 15px;
      position: relative;
    }
    
    .dialogue-button {
      padding: 12px 25px;
      font-size: 16px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .dialogue-button:hover {
      background-color: #2980b9;
    }
    
    .dialogue-button:active {
      background-color: #21618c;
    }
    
    #close-confrontation-btn {
      background-color: #e74c3c;
      position: absolute;
      right: 0;
      bottom: 0;
      display: none;
      pointer-events: none;
    }
    
    #close-confrontation-btn.visible {
      display: inline-block;
      pointer-events: auto;
    }
    
    #close-confrontation-btn:hover {
      background-color: #c0392b;
    }
    
    #close-confrontation-btn:active {
      background-color: #a93226;
    }
    
    /* Mini-jeu de cartes */
    #cards-game-container {
      position: absolute;
      bottom: 26%;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      z-index: 1002;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    
    #cards-game-container.visible {
      visibility: visible;
      opacity: 1;
    }
    
    .card {
      width: 80px;
      height: 112px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7);
    }
    
    .card-player-hand {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
    }
    
    .card-player-played {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      border-color: #3498db;
    }
    
    .card-npc-hand {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
    }
    
    .card-npc-played {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      border-color: #e74c3c;
    }
    
    .card-center {
      background-image: url('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg');
      background-color: rgba(50, 50, 50, 0.5);
      border: 2px dashed rgba(255, 255, 255, 0.3);
    }
    
    /* Positions sp√©cifiques dans la grille */
    #card-player-1 { grid-column: 1; grid-row: 1; }
    #card-player-2 { grid-column: 2; grid-row: 1; }
    #card-player-3 { grid-column: 3; grid-row: 1; }
    #card-player-played { grid-column: 1; grid-row: 2; }
    #card-center { grid-column: 2; grid-row: 2; }
    #card-npc-played { grid-column: 3; grid-row: 2; }
    #card-npc-1 { grid-column: 1; grid-row: 3; }
    #card-npc-2 { grid-column: 2; grid-row: 3; }
    #card-npc-3 { grid-column: 3; grid-row: 3; }
    
    /* Affichage du r√©sultat de tour */
    #result-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 72px;
      font-weight: bold;
      color: white;
      text-shadow: 
        -3px -3px 0 #000,
        3px -3px 0 #000,
        -3px 3px 0 #000,
        3px 3px 0 #000,
        0 0 20px rgba(0, 0, 0, 0.8);
      z-index: 1003;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #result-display.show {
      opacity: 1;
      animation: shake 0.5s infinite;
    }
    
    @keyframes shake {
      0%, 100% { 
        transform: translate(-50%, -50%) rotate(0deg) scale(1);
      }
      10% { 
        transform: translate(-48%, -52%) rotate(-2deg) scale(1.05);
      }
      20% { 
        transform: translate(-52%, -48%) rotate(2deg) scale(0.95);
      }
      30% { 
        transform: translate(-49%, -51%) rotate(-1deg) scale(1.02);
      }
      40% { 
        transform: translate(-51%, -49%) rotate(1deg) scale(0.98);
      }
      50% { 
        transform: translate(-50%, -50%) rotate(0deg) scale(1.03);
      }
      60% { 
        transform: translate(-52%, -51%) rotate(-2deg) scale(1.01);
      }
      70% { 
        transform: translate(-48%, -49%) rotate(2deg) scale(0.97);
      }
      80% { 
        transform: translate(-51%, -50%) rotate(-1deg) scale(1.04);
      }
      90% { 
        transform: translate(-49%, -52%) rotate(1deg) scale(0.99);
      }
    }
    
    /* Indicateur de zone cliquable */
    #click-indicator {
      position: absolute;
      border: 4px solid gold;
      border-radius: 8px;
      background-color: rgba(255, 215, 0, 0.2);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
      z-index: 1004;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      animation: pulse-glow 0.6s infinite alternate;
    }
    
    #click-indicator.show {
      opacity: 1;
    }
    
    @keyframes pulse-glow {
      0% {
        transform: scale(1);
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 215, 0, 0.3);
        border-color: gold;
      }
      100% {
        transform: scale(1.05);
        box-shadow: 0 0 30px rgba(255, 215, 0, 1), inset 0 0 30px rgba(255, 215, 0, 0.5);
        border-color: rgba(255, 215, 0, 0.7);
      }
    }
    
    /* Affichage des points gagn√©s/perdus */
    #points-display {
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 42px;
      font-weight: bold;
      z-index: 1005;
      pointer-events: none;
      opacity: 0;
      display: none;
      text-shadow: 
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        2px 2px 0 #000,
        0 0 15px rgba(0, 0, 0, 0.8);
    }
    
    #points-display.show {
      opacity: 1;
      animation: float-up 2s ease-out forwards;
    }
    
    @keyframes float-up {
      0% {
        transform: translateY(0) scale(0.8);
        opacity: 0;
      }
      10% {
        opacity: 1;
        transform: translateY(-5px) scale(1.1);
      }
      90% {
        opacity: 1;
        transform: translateY(-15px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
    }
  </style>
</head>
<body>
  <!-- Volet de confrontation -->
  <div id="confrontation-panel">
    <!-- Images des personnages -->
    <div class="character-container" id="antagonist-image">
      <img src="https://res.cloudinary.com/dgrcmakbt/image/upload/v1764444404/ChatGPT_Image_27_nov._2025_21_35_18_mfe5bx.png" alt="Antagoniste" class="character-image">
    </div>
    <div class="character-container" id="player-image">
      <img src="https://res.cloudinary.com/dgrcmakbt/image/upload/v1764444404/ChatGPT_Image_27_nov._2025_21_35_18_mfe5bx.png" alt="Joueur" class="character-image">
    </div>
    
    <!-- Mini-jeu de cartes -->
    <div id="cards-game-container">
      <!-- Ligne du haut : Main du joueur (3 cartes) -->
      <div class="card card-player-hand" id="card-player-1"></div>
      <div class="card card-player-hand" id="card-player-2"></div>
      <div class="card card-player-hand" id="card-player-3"></div>
      
      <!-- Ligne du milieu : Cartes jou√©es -->
      <div class="card card-player-played" id="card-player-played"></div>
      <div class="card card-center" id="card-center"></div>
      <div class="card card-npc-played" id="card-npc-played"></div>
      
      <!-- Ligne du bas : Main du NPC (3 cartes) -->
      <div class="card card-npc-hand" id="card-npc-1"></div>
      <div class="card card-npc-hand" id="card-npc-2"></div>
      <div class="card card-npc-hand" id="card-npc-3"></div>
    </div>
    
    <!-- Affichage du r√©sultat -->
    <div id="result-display"></div>
    
    <!-- Indicateur de zone cliquable -->
    <div id="click-indicator"></div>
    
    <!-- Affichage des points gagn√©s/perdus -->
    <div id="points-display"></div>
    
    <!-- Bloc de dialogue -->
    <div id="dialogue-container">
      <div id="character-name-box">
        <p id="character-name">Nom de l'antagoniste</p>
      </div>
      <div id="dialogue-box">
        <p id="dialogue-text">Bonjour je suis le Pion n¬∞ 1</p>
        <div id="dialogue-controls">
          <button class="dialogue-button" id="next-page-btn">Next Page</button>
          <button class="dialogue-button" id="close-confrontation-btn">Refermer</button>
        </div>
      </div>
    </div>
  </div>
  
  <div id="container">
    <!-- Affichage des jauges -->
    <div id="gauges-display">
      <div class="gauge">
        <p class="gauge-label">Heures d'Enqu√™te</p>
        <p class="gauge-value" id="heures-value">15</p>
      </div>
      <div class="gauge">
        <p class="gauge-label">Confrontation</p>
        <p class="gauge-value" id="confrontation-value">0</p>
      </div>
      <div class="gauge">
        <p class="gauge-label">Alignement</p>
        <p class="gauge-value" id="alignement-value">0</p>
      </div>
    </div>
    
    <!-- Croix directionnelle en X -->
    <div id="dpad-container">
      <div class="dpad-button" id="dpad-UR">
        <span>‚áñ</span>
      </div>
      <div class="dpad-button" id="dpad-BR">
        <span>‚áó</span>
      </div>
      <div class="dpad-button" id="dpad-BL">
        <span>‚áò</span>
      </div>
      <div class="dpad-button" id="dpad-UL">
        <span>‚áô</span>
      </div>
      <div class="dpad-button" id="dpad-center">
        <span>üî•</span>
      </div>
    </div>
  </div>
  <div id="controls">
    <button id="rotateLeftBtn">Rotate -90¬∞</button>
    <button id="rotateRightBtn">Rotate 90¬∞</button>
    <button id="zoomBtn">Zoom</button>
    <button id="resetBtn">Recommencer</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, checkerboard;
    let pions = []; // Tableau pour stocker tous les pions
    let redPion = null; // R√©f√©rence au pion rouge
    let isRotating = false;
    let targetRotation = 0;
    let isZoomed = false;
    let isZooming = false;
    let targetCameraPos = { x: 0, y: 12, z: 10 };
    let targetCameraLookAt = { x: 0, y: 0, z: 0 };
    const boardSize = 15;
    const squareSize = 0.6;
    const pionTypes = [
      { color: '#ff0000', count: 1 },  // 1 pion rouge
      { color: '#00ff00', count: 5 },  // 5 pions verts
      { color: '#9900ff', count: 3 }   // 3 pions violets
    ];
    let roadPositions = []; // Liste des positions de routes (cases gris clair)
    let cityMap = []; // Carte de la ville
    let squareMeshes = {}; // Dictionnaire pour acc√©der aux meshes des cases
    let accessibleCells = []; // Cases accessibles au pion rouge
    let isPlayerTurn = true; // Tour du joueur
    let confrontedPion = null; // Pion qui a d√©clench√© la confrontation
    let currentDialoguePage = 0; // Page actuelle du dialogue
    let currentRotationStep = 0; // √âtape de rotation actuelle (0, 1, 2, 3 pour 0¬∞, 90¬∞, 180¬∞, 270¬∞)
    const moveRange = 3; // Range de d√©placement
    
    // Jauges de points du joueur
    let heuresEnquete = 15; // Points de d√©placement
    let pointsConfrontation = 0; // Points de confrontation (r√©initialis√©s apr√®s chaque confrontation)
    let pointsAlignement = 0; // Points d'alignement/vertu (peuvent √™tre positifs ou n√©gatifs)
    let confrontationCount = 0; // Nombre de confrontations effectu√©es
    let startTurnPosition = { row: 0, col: 0 }; // Position au d√©but du tour
    let pointsGagnesConfrontation = 0; // Total des points gagn√©s/perdus pendant la confrontation actuelle
    
    // Inventaire de cartes collect√©es
    let cartesCollectees = []; // Inventaire global du joueur
    
    // Base de donn√©es des cartes
    const cardsDatabase = [
      { nom: "Pierre", vsPierre: 2, vsFeuille: 0, vsCiseaux: 1, vsPuits: 0, vsFeu: 1, vsSablier: 0, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512932/card000002_fqmuqv.png" },
      { nom: "Feuille", vsPierre: 1, vsFeuille: 2, vsCiseaux: 0, vsPuits: 1, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 0, vsPie: 1, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512932/card000003_wmqjnf.png" },
      { nom: "Ciseaux", vsPierre: 0, vsFeuille: 1, vsCiseaux: 2, vsPuits: 0, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 1, vsPie: 0, vsJoker: 0, occurrence: 1, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764512933/card000004_jvc95e.png" },
      { nom: "Puits", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 2, vsFeu: 1, vsSablier: 0, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 3, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Feu", vsPierre: 0, vsFeuille: 1, vsCiseaux: 1, vsPuits: 0, vsFeu: 2, vsSablier: 0, vsVent: 1, vsAcanthe: 1, vsPie: 1, vsJoker: 0, occurrence: 5, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Sablier", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 0, vsFeu: 0, vsSablier: 2, vsVent: 1, vsAcanthe: 0, vsPie: 0, vsJoker: 0, occurrence: 7, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Vent", vsPierre: 0, vsFeuille: 1, vsCiseaux: 1, vsPuits: 0, vsFeu: 0, vsSablier: 0, vsVent: 2, vsAcanthe: 1, vsPie: 1, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Acanthe", vsPierre: 1, vsFeuille: 1, vsCiseaux: 0, vsPuits: 1, vsFeu: 0, vsSablier: 0, vsVent: 0, vsAcanthe: 2, vsPie: 1, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Pie", vsPierre: 1, vsFeuille: 0, vsCiseaux: 1, vsPuits: 1, vsFeu: 0, vsSablier: 1, vsVent: 0, vsAcanthe: 0, vsPie: 2, vsJoker: 0, occurrence: 10, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" },
      { nom: "Joker", vsPierre: 1, vsFeuille: 1, vsCiseaux: 1, vsPuits: 1, vsFeu: 1, vsSablier: 1, vsVent: 1, vsAcanthe: 1, vsPie: 1, vsJoker: 1, occurrence: 17, img: "https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg" }
    ];
    
    // √âtat du mini-jeu
    let gameState = {
      isGameActive: false,
      currentTurn: 0,
      playerHasInitiative: false,
      deckJoueur: [],
      deckAdversaire: [],
      mainJoueur: [],
      mainAdversaire: [],
      carteJoueeJoueur: null,
      carteJoueeAdversaire: null,
      waitingForPlayerAction: false,
      actionType: null, // "draw", "play"
      isPaused: false // Jeu en pause pendant l'indicateur
    };
    
    // Dialogues pour chaque type de pion
    const dialogues = {
      green: {
        name: "Pion Vert",
        pages: [
          "Bonjour je suis le Pion Vert n¬∞ 1 ! Je garde ce secteur de la ville.",
          "Tu ne passeras pas si facilement. Pr√©pare-toi √† affronter ma d√©termination !",
          "Bon... peut-√™tre une autre fois. Je dois y aller maintenant !"
        ]
      },
      purple: {
        name: "Pion Violet",
        pages: [
          "Ah, nous nous rencontrons enfin. Je suis le Pion Violet.",
          "On m'a pr√©venu de ta venue dans ces rues. Tu es courageux de venir jusqu'ici.",
          "Cette confrontation est termin√©e pour aujourd'hui. √Ä bient√¥t, voyageur."
        ]
      },
      default: {
        name: "Antagoniste",
        pages: [
          "Bonjour, √©tranger.",
          "Que fais-tu dans ce quartier ?"
        ]
      }
    };
    
    function init() {
      // Cr√©er la sc√®ne
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      
      // Cr√©er la cam√©ra (vue en trois-quarts plong√©e avec face sup√©rieure horizontale)
      camera = new THREE.PerspectiveCamera(
        50,
        1,
        0.1,
        1000
      );
      camera.position.set(0, 12, 10);
      camera.lookAt(0, 0, 0);
      
      // Cr√©er le renderer
      const container = document.getElementById('container');
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(600, 600);
      container.insertBefore(renderer.domElement, container.firstChild);
      
      // Cr√©er la skysphere
      createSkysphere();
      
      // Cr√©er le damier 15x15
      checkerboard = new THREE.Group();
      
      // G√©n√©rer le r√©seau routier
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // V√©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // D√©terminer si c'est une route ou un b√¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444 // Gris clair pour routes, gris fonc√© pour b√¢timents
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }
      
      // Rotation initiale √† +45¬∞ pour pr√©senter un coin face cam√©ra
      checkerboard.rotation.y = Math.PI / 4; // 45 degr√©s
      targetRotation = checkerboard.rotation.y;
      
      scene.add(checkerboard);
      
      // Cr√©er tous les pions
      createAllPions();
      
      // D√©marrer le tour du joueur
      startPlayerTurn();
      
      // Mettre √† jour l'affichage des jauges
      updateGaugesDisplay();
      
      animate();
    }
    
    function createSkysphere() {
      // Cr√©er une sph√®re invers√©e (texture √† l'int√©rieur)
      const geometry = new THREE.SphereGeometry(100, 64, 64);
      
      // Charger la texture
      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load('https://res.cloudinary.com/dgrcmakbt/image/upload/v1764366928/uzralk_texture_for_3D_skysphere_video_game_texture_futuristic_i_ea3bf670-69cf-42b7-9daf-c4fd4040b193_d5nsmp.png');
      
      // Cr√©er le mat√©riau avec la texture √† l'int√©rieur
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.BackSide, // Rendre visible l'int√©rieur de la sph√®re
        transparent: false
      });
      
      skysphere = new THREE.Mesh(geometry, material);
      
      // Rotation initiale pour aligner avec le damier
      // La rotation de 45¬∞ correspond √† l'orientation initiale du damier
      skysphere.rotation.y = Math.PI / 4; // 45 degr√©s
      
      scene.add(skysphere);
    }
    
    function generateCityMap() {
      // Cr√©er une grille initiale remplie de b√¢timents (false)
      const map = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      // Liste de toutes les positions des routes
      const roadCells = [];
      
      // Commencer au centre
      let currentRow = Math.floor(boardSize / 2);
      let currentCol = Math.floor(boardSize / 2);
      map[currentRow][currentCol] = true;
      roadCells.push({ row: currentRow, col: currentCol });
      
      const numSegments = 18 + Math.floor(Math.random() * 8); // 18-25 tron√ßons pour mieux couvrir
      
      for (let segment = 0; segment < numSegments; segment++) {
        // Choisir un point de d√©part parmi les routes existantes
        const startPoint = roadCells[Math.floor(Math.random() * roadCells.length)];
        currentRow = startPoint.row;
        currentCol = startPoint.col;
        
        // Choisir une direction al√©atoire (0: haut, 1: droite, 2: bas, 3: gauche)
        const direction = Math.floor(Math.random() * 4);
        // Longueur du tron√ßon (minimum 3 cases, maximum 6 cases)
        const length = 3 + Math.floor(Math.random() * 4);
        
        let deltaRow = 0, deltaCol = 0;
        if (direction === 0) deltaRow = -1; // Haut
        else if (direction === 1) deltaCol = 1; // Droite
        else if (direction === 2) deltaRow = 1; // Bas
        else if (direction === 3) deltaCol = -1; // Gauche
        
        // V√©rifier si le tron√ßon peut √™tre cr√©√© sans violer les r√®gles
        let canCreate = true;
        let tempRow = currentRow;
        let tempCol = currentCol;
        const newCells = [];
        
        for (let step = 0; step < length; step++) {
          tempRow += deltaRow;
          tempCol += deltaCol;
          
          // V√©rifier les limites
          if (tempRow < 0 || tempRow >= boardSize || 
              tempCol < 0 || tempCol >= boardSize) {
            canCreate = false;
            break;
          }
          
          newCells.push({ row: tempRow, col: tempCol });
          
          // V√©rifier qu'il n'y a pas de tron√ßons parall√®les coll√©s
          if (!canCreate) break;
          
          // Pour un tron√ßon horizontal (direction gauche/droite)
          if (direction === 1 || direction === 3) {
            // V√©rifier au-dessus et en-dessous
            if (tempRow > 0 && map[tempRow - 1][tempCol] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon horizontal parall√®le
              if ((tempCol > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow - 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempRow < boardSize - 1 && map[tempRow + 1][tempCol] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon horizontal parall√®le
              if ((tempCol > 0 && map[tempRow + 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
          
          // Pour un tron√ßon vertical (direction haut/bas)
          if (direction === 0 || direction === 2) {
            // V√©rifier √† gauche et √† droite
            if (tempCol > 0 && map[tempRow][tempCol - 1] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon vertical parall√®le
              if ((tempRow > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol - 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempCol < boardSize - 1 && map[tempRow][tempCol + 1] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon vertical parall√®le
              if ((tempRow > 0 && map[tempRow - 1][tempCol + 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
        }
        
        // Cr√©er le tron√ßon seulement s'il est valide
        if (canCreate) {
          for (const cell of newCells) {
            if (!map[cell.row][cell.col]) {
              map[cell.row][cell.col] = true;
              roadCells.push(cell);
            }
          }
        }
      }
      
      // S'assurer que chaque zone 4x4 contient au moins une route
      for (let blockRow = 0; blockRow < boardSize - 3; blockRow += 4) {
        for (let blockCol = 0; blockCol < boardSize - 3; blockCol += 4) {
          let hasRoad = false;
          
          // V√©rifier si ce bloc 4x4 a au moins une route
          for (let r = blockRow; r < Math.min(blockRow + 4, boardSize); r++) {
            for (let c = blockCol; c < Math.min(blockCol + 4, boardSize); c++) {
              if (map[r][c]) {
                hasRoad = true;
                break;
              }
            }
            if (hasRoad) break;
          }
          
          // Si pas de route, en cr√©er une connect√©e au r√©seau le plus proche
          if (!hasRoad && roadCells.length > 0) {
            // Trouver la route la plus proche de ce bloc
            let closestRoad = null;
            let minDistance = Infinity;
            
            const blockCenterRow = blockRow + 1.5;
            const blockCenterCol = blockCol + 1.5;
            
            for (const road of roadCells) {
              const dist = Math.abs(road.row - blockCenterRow) + Math.abs(road.col - blockCenterCol);
              if (dist < minDistance) {
                minDistance = dist;
                closestRoad = road;
              }
            }
            
            // Cr√©er un chemin depuis la route la plus proche vers ce bloc
            if (closestRoad) {
              let pathRow = closestRoad.row;
              let pathCol = closestRoad.col;
              const targetRow = Math.floor(blockCenterRow);
              const targetCol = Math.floor(blockCenterCol);
              
              // Cr√©er un chemin simple (Manhattan)
              while (pathRow !== targetRow || pathCol !== targetCol) {
                if (pathRow < targetRow) pathRow++;
                else if (pathRow > targetRow) pathRow--;
                else if (pathCol < targetCol) pathCol++;
                else if (pathCol > targetCol) pathCol--;
                
                if (pathRow >= 0 && pathRow < boardSize && pathCol >= 0 && pathCol < boardSize) {
                  if (!map[pathRow][pathCol]) {
                    map[pathRow][pathCol] = true;
                    roadCells.push({ row: pathRow, col: pathCol });
                  }
                }
              }
            }
          }
        }
      }
      
      return map;
    }
    
    function addLandmarks(map) {
      // Ajouter des lieux dits : 8 rouges, 1 bleu, 1 vert
      const landmarks = [];
      const landmarkTypes = [
        { color: 0x8B0000, count: 8, type: 'red' },   // 8 cases rouge sombre
        { color: 0x00008B, count: 1, type: 'blue' },  // 1 case bleu sombre
        { color: 0x006400, count: 1, type: 'green' }  // 1 case vert sombre
      ];
      
      // Cr√©er un tableau pour marquer les positions des landmarks
      const landmarkMap = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      for (const landmarkType of landmarkTypes) {
        for (let i = 0; i < landmarkType.count; i++) {
          let placed = false;
          let attempts = 0;
          
          while (!placed && attempts < 500) {
            attempts++;
            const row = Math.floor(Math.random() * boardSize);
            const col = Math.floor(Math.random() * boardSize);
            
            // V√©rifier que c'est un b√¢timent (pas une route)
            if (map[row][col] || landmarkMap[row][col]) continue;
            
            // V√©rifier qu'il y a au moins une route adjacente
            let hasAdjacentRoad = false;
            if (row > 0 && map[row - 1][col]) hasAdjacentRoad = true;
            if (row < boardSize - 1 && map[row + 1][col]) hasAdjacentRoad = true;
            if (col > 0 && map[row][col - 1]) hasAdjacentRoad = true;
            if (col < boardSize - 1 && map[row][col + 1]) hasAdjacentRoad = true;
            
            if (!hasAdjacentRoad) continue;
            
            // V√©rifier qu'aucun autre landmark n'est adjacent
            let hasAdjacentLandmark = false;
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                  if (landmarkMap[nr][nc]) {
                    hasAdjacentLandmark = true;
                    break;
                  }
                }
              }
              if (hasAdjacentLandmark) break;
            }
            
            if (hasAdjacentLandmark) continue;
            
            // Placer le landmark
            landmarkMap[row][col] = true;
            landmarks.push({ row, col, color: landmarkType.color, type: landmarkType.type });
            placed = true;
          }
        }
      }
      
      return landmarks;
    }
    
    function createBuilding(type, size) {
      // Cr√©er un groupe pour l'immeuble
      const building = new THREE.Group();
      
      // D√©terminer la couleur pastel et le nombre d'√©tages selon le type
      let color, floors;
      if (type === 'red') {
        color = 0xffb3ba; // Rose pastel
        floors = Math.random() < 0.5 ? 2 : 3; // 2 ou 3 √©tages
      } else if (type === 'blue') {
        color = 0xbae1ff; // Bleu pastel
        floors = 3;
      } else { // green
        color = 0xbaffc9; // Vert pastel
        floors = 3;
      }
      
      // Cr√©er les √©tages (cubes empil√©s)
      for (let i = 0; i < floors; i++) {
        const floorGeometry = new THREE.BoxGeometry(size, size, size);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: color });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Positionner chaque √©tage
        floor.position.y = 0.15 + size / 2 + i * size;
        
        // Ajouter des ar√™tes pour mieux voir la structure
        const edges = new THREE.EdgesGeometry(floorGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        floor.add(wireframe);
        
        building.add(floor);
      }
      
      // Ajouter un toit biseaut√© sur le dernier √©tage
      const roofHeight = size * 0.3;
      const roofGeometry = createBeveledRoofGeometry(size, roofHeight);
      const roofMaterial = new THREE.MeshBasicMaterial({ color: color });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      
      // Positionner le toit au-dessus du dernier √©tage
      roof.position.y = 0.15 + floors * size;
      
      // Ajouter des ar√™tes au toit
      const roofEdges = new THREE.EdgesGeometry(roofGeometry);
      const roofLineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
      const roofWireframe = new THREE.LineSegments(roofEdges, roofLineMaterial);
      roof.add(roofWireframe);
      
      building.add(roof);
      
      return building;
    }
    
    function createBeveledRoofGeometry(size, height) {
      // Cr√©er un toit biseaut√© (pyramide tronqu√©e sur une face)
      const shape = new THREE.Shape();
      
      // Base du toit (carr√©)
      const halfSize = size / 2;
      
      // Cr√©er une g√©om√©trie personnalis√©e pour le toit biseaut√©
      const geometry = new THREE.BufferGeometry();
      
      // D√©finir les sommets
      const vertices = new Float32Array([
        // Base (y = 0)
        -halfSize, 0, -halfSize,  // 0
        halfSize, 0, -halfSize,   // 1
        halfSize, 0, halfSize,    // 2
        -halfSize, 0, halfSize,   // 3
        
        // Sommet biseaut√© (y = height, d√©cal√© vers l'avant)
        -halfSize * 0.3, height, -halfSize * 0.3,  // 4
        halfSize * 0.3, height, -halfSize * 0.3,   // 5
        halfSize * 0.3, height, halfSize * 0.3,    // 6
        -halfSize * 0.3, height, halfSize * 0.3    // 7
      ]);
      
      // D√©finir les faces (triangles)
      const indices = [
        // Base
        0, 2, 1,  0, 3, 2,
        
        // C√¥t√©s
        0, 1, 5,  0, 5, 4,  // Face avant
        1, 2, 6,  1, 6, 5,  // Face droite
        2, 3, 7,  2, 7, 6,  // Face arri√®re
        3, 0, 4,  3, 4, 7,  // Face gauche
        
        // Sommet
        4, 5, 6,  4, 6, 7
      ];
      
      geometry.setIndex(indices);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    
    function updateGaugesDisplay() {
      // Mettre √† jour l'affichage des jauges
      document.getElementById('heures-value').textContent = heuresEnquete;
      document.getElementById('confrontation-value').textContent = pointsConfrontation;
      
      const alignementElement = document.getElementById('alignement-value');
      alignementElement.textContent = pointsAlignement > 0 ? `+${pointsAlignement}` : pointsAlignement;
      
      // Changer la couleur selon le signe
      alignementElement.classList.remove('positive', 'negative');
      if (pointsAlignement > 0) {
        alignementElement.classList.add('positive');
      } else if (pointsAlignement < 0) {
        alignementElement.classList.add('negative');
      }
    }
    
    // ===== FONCTIONS DU MINI-JEU DE CARTES =====
    
    function startCardGame() {
      console.log("=== D√âBUT DU MINI-JEU ===");
      gameState.isGameActive = true;
      gameState.currentTurn = 0;
      
      // Rendre le tableau de cartes visible
      const cardsContainer = document.getElementById('cards-game-container');
      cardsContainer.classList.add('visible');
      
      // Tirer l'initiative au hasard
      gameState.playerHasInitiative = Math.random() < 0.5;
      console.log(`Initiative: ${gameState.playerHasInitiative ? "Joueur" : "Adversaire"}`);
      
      // Pr√©parer les decks
      preparerDecks();
      
      // D√©marrer le premier tour
      setTimeout(() => {
        if (gameState.playerHasInitiative) {
          demarrerTourJoueurInitiative();
        } else {
          demarrerTourAdversaireInitiative();
        }
      }, 1000);
    }
    
    function preparerDecks() {
      // Deck du joueur : 3 Pierre, 3 Feuille, 3 Ciseaux + cartes collect√©es
      gameState.deckJoueur = [];
      for (let i = 0; i < 3; i++) {
        gameState.deckJoueur.push(cardsDatabase[0]); // Pierre
        gameState.deckJoueur.push(cardsDatabase[1]); // Feuille
        gameState.deckJoueur.push(cardsDatabase[2]); // Ciseaux
      }
      
      // Ajouter les cartes collect√©es
      gameState.deckJoueur = gameState.deckJoueur.concat(cartesCollectees);
      
      // M√©langer le deck
      shuffleDeck(gameState.deckJoueur);
      
      // Deck adversaire : cartes bonus selon l'inventaire du joueur
      gameState.deckAdversaire = [];
      const nbCartesBonus = Math.max(0, cartesCollectees.length - 1);
      
      for (let i = 0; i < nbCartesBonus; i++) {
        const carte = tirerCarteAleatoire(cardsDatabase);
        gameState.deckAdversaire.push(carte);
      }
      
      console.log(`Deck Joueur: ${gameState.deckJoueur.length} cartes`);
      console.log(`Deck Adversaire: ${gameState.deckAdversaire.length} cartes`);
    }
    
    function shuffleDeck(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }
    
    function tirerCarteAleatoire(source) {
      // Tirer selon l'occurrence
      const totalOccurrence = source.reduce((sum, card) => sum + card.occurrence, 0);
      let random = Math.random() * totalOccurrence;
      
      for (const card of source) {
        random -= card.occurrence;
        if (random <= 0) {
          return card;
        }
      }
      
      return source[0];
    }
    
    function demarrerTourJoueurInitiative() {
      gameState.currentTurn++;
      console.log(`=== TOUR ${gameState.currentTurn} - Joueur a l'initiative ===`);
      
      clearCardsDisplay();
      
      // Afficher le message de d√©but de tour
      const dialogueText = document.getElementById('dialogue-text');
      dialogueText.textContent = `Tour de Jeu n¬∞${gameState.currentTurn}, Initiative : Joueur`;
      
      // Le joueur commence avec une main vide - il va tirer 3 cartes
      gameState.mainJoueur = [];
      
      // Distribuer 3 cartes √† l'adversaire
      const cartesDeBase = [cardsDatabase[0], cardsDatabase[1], cardsDatabase[2]];
      gameState.mainAdversaire = [];
      for (let i = 0; i < 3; i++) {
        // Tirer depuis le deck adversaire s'il a des cartes, sinon depuis les cartes de base
        if (gameState.deckAdversaire.length > 0) {
          const carte = gameState.deckAdversaire.pop();
          gameState.mainAdversaire.push(carte);
        } else {
          // Si le deck adversaire est vide, utiliser des cartes de base
          const carte = cartesDeBase[Math.floor(Math.random() * 3)];
          gameState.mainAdversaire.push(carte);
        }
      }
      
      afficherCartes();
      afficherDeckCentral(); // Afficher le deck car le joueur va devoir cliquer dessus
      
      // Afficher le message d'instruction apr√®s un court d√©lai
      setTimeout(() => {
        dialogueText.textContent = "Cliquez sur le deck central pour tirer une carte au hasard et composer votre Main.";
      }, 1500);
      
      // Afficher l'indicateur pour la carte centrale
      setTimeout(() => {
        afficherIndicateurZone('center');
      }, 2000);
      
      // Inviter le joueur √† tirer sa premi√®re carte
      gameState.waitingForPlayerAction = true;
      gameState.actionType = "draw";
      console.log("Cliquez sur le deck pour tirer vos cartes (1/3)");
    }
    
    function demarrerTourAdversaireInitiative() {
      gameState.currentTurn++;
      console.log(`=== TOUR ${gameState.currentTurn} - Adversaire a l'initiative ===`);
      
      clearCardsDisplay();
      
      // Afficher le message de d√©but de tour
      const dialogueText = document.getElementById('dialogue-text');
      dialogueText.textContent = `Tour de Jeu n¬∞${gameState.currentTurn}, Initiative : Adversaire`;
      
      // Le joueur commence avec une main vide - il va tirer 3 cartes
      gameState.mainJoueur = [];
      
      // Distribuer 3 cartes √† l'adversaire
      const cartesDeBase = [cardsDatabase[0], cardsDatabase[1], cardsDatabase[2]];
      gameState.mainAdversaire = [];
      for (let i = 0; i < 3; i++) {
        // Tirer depuis le deck adversaire s'il a des cartes, sinon depuis les cartes de base
        if (gameState.deckAdversaire.length > 0) {
          const carte = gameState.deckAdversaire.pop();
          gameState.mainAdversaire.push(carte);
        } else {
          // Si le deck adversaire est vide, utiliser des cartes de base
          const carte = cartesDeBase[Math.floor(Math.random() * 3)];
          gameState.mainAdversaire.push(carte);
        }
      }
      
      afficherCartes();
      
      // L'adversaire joue une carte
      setTimeout(() => {
        dialogueText.textContent = "L'adversaire engage une carte...";
        
        setTimeout(() => {
          adversaireJoueCarte();
          
          // Afficher le deck car le joueur va devoir cliquer dessus
          afficherDeckCentral();
          
          // Message d'instruction
          setTimeout(() => {
            dialogueText.textContent = "Cliquez sur le deck central pour tirer une carte au hasard et composer votre Main.";
          }, 500);
          
          // Afficher l'indicateur pour la carte centrale
          setTimeout(() => {
            afficherIndicateurZone('center');
          }, 1000);
          
          // Inviter le joueur √† tirer sa premi√®re carte
          gameState.waitingForPlayerAction = true;
          gameState.actionType = "draw";
          console.log("Cliquez sur le deck pour tirer vos cartes (1/3)");
        }, 1000);
      }, 1500);
    }
    
    function retirerCarteDuDeck(deck, carte) {
      const index = deck.findIndex(c => c.nom === carte.nom);
      if (index !== -1) {
        deck.splice(index, 1);
      }
    }
    
    function afficherCartes() {
      // Afficher main du joueur
      for (let i = 0; i < 3; i++) {
        const cardEl = document.getElementById(`card-player-${i + 1}`);
        if (cardEl) {
          if (i < gameState.mainJoueur.length) {
            cardEl.style.backgroundImage = `url('${gameState.mainJoueur[i].img}')`;
            cardEl.style.backgroundColor = '';
            cardEl.style.visibility = 'visible';
          } else {
            // Laisser l'emplacement vide
            cardEl.style.backgroundImage = 'none';
            cardEl.style.backgroundColor = 'rgba(50, 50, 50, 0.3)';
            cardEl.style.visibility = 'visible';
          }
        }
      }
      
      // Afficher main de l'adversaire
      for (let i = 0; i < 3; i++) {
        const cardEl = document.getElementById(`card-npc-${i + 1}`);
        if (cardEl) {
          if (i < gameState.mainAdversaire.length) {
            cardEl.style.backgroundImage = `url('${gameState.mainAdversaire[i].img}')`;
            cardEl.style.backgroundColor = '';
            cardEl.style.visibility = 'visible';
          } else {
            // Laisser l'emplacement vide
            cardEl.style.backgroundImage = 'none';
            cardEl.style.backgroundColor = 'rgba(50, 50, 50, 0.3)';
            cardEl.style.visibility = 'visible';
          }
        }
      }
      
      // Ne PAS afficher la carte centrale ici - elle sera g√©r√©e s√©par√©ment
      
      // Afficher les cartes jou√©es si elles existent
      if (gameState.carteJoueeJoueur) {
        const cardEl = document.getElementById('card-player-played');
        cardEl.style.backgroundImage = `url('${gameState.carteJoueeJoueur.img}')`;
        cardEl.style.backgroundColor = '';
        cardEl.style.visibility = 'visible';
      }
      
      if (gameState.carteJoueeAdversaire) {
        const cardEl = document.getElementById('card-npc-played');
        cardEl.style.backgroundImage = `url('${gameState.carteJoueeAdversaire.img}')`;
        cardEl.style.backgroundColor = '';
        cardEl.style.visibility = 'visible';
      }
    }
    
    function afficherDeckCentral() {
      const centerCard = document.getElementById('card-center');
      if (centerCard) {
        centerCard.style.visibility = 'visible';
        centerCard.style.backgroundImage = 'url("https://res.cloudinary.com/dgrcmakbt/image/upload/v1764453807/card000001_qqnqyi.jpg")';
        centerCard.style.backgroundColor = '';
      }
    }
    
    function masquerDeckCentral() {
      const centerCard = document.getElementById('card-center');
      if (centerCard) {
        centerCard.style.visibility = 'hidden';
        centerCard.style.backgroundImage = 'none';
        centerCard.style.backgroundColor = '';
      }
    }
    
    function clearCardsDisplay() {
      // Cacher toutes les cartes sauf le deck central
      for (let i = 1; i <= 3; i++) {
        const playerCard = document.getElementById(`card-player-${i}`);
        const npcCard = document.getElementById(`card-npc-${i}`);
        if (playerCard) {
          playerCard.style.visibility = 'hidden';
          playerCard.style.backgroundImage = 'none';
          playerCard.style.backgroundColor = '';
        }
        if (npcCard) {
          npcCard.style.visibility = 'hidden';
          npcCard.style.backgroundImage = 'none';
          npcCard.style.backgroundColor = '';
        }
      }
      
      const playerPlayed = document.getElementById('card-player-played');
      const npcPlayed = document.getElementById('card-npc-played');
      const centerCard = document.getElementById('card-center');
      
      if (playerPlayed) {
        playerPlayed.style.visibility = 'hidden';
        playerPlayed.style.backgroundImage = 'none';
        playerPlayed.style.backgroundColor = '';
      }
      if (npcPlayed) {
        npcPlayed.style.visibility = 'hidden';
        npcPlayed.style.backgroundImage = 'none';
        npcPlayed.style.backgroundColor = '';
      }
      if (centerCard) {
        centerCard.style.visibility = 'hidden';
        centerCard.style.backgroundImage = 'none';
        centerCard.style.backgroundColor = '';
      }
      
      gameState.carteJoueeJoueur = null;
      gameState.carteJoueeAdversaire = null;
    }
    
    function joueurTireCarte() {
      if (gameState.deckJoueur.length > 0 && gameState.mainJoueur.length < 3) {
        const carte = gameState.deckJoueur.pop();
        gameState.mainJoueur.push(carte);
        afficherCartes();
        
        const nbCartes = gameState.mainJoueur.length;
        console.log(`Carte tir√©e (${nbCartes}/3)`);
        
        // Si le joueur a tir√© 3 cartes, il peut maintenant choisir
        if (nbCartes >= 3) {
          // Masquer le deck apr√®s avoir tir√© toutes les cartes
          masquerDeckCentral();
          
          gameState.actionType = "play";
          
          // Afficher l'indicateur pour la main du joueur
          setTimeout(() => {
            afficherIndicateurZone('player-hand');
          }, 500);
          
          console.log("Choisissez une carte √† jouer");
        } else {
          // Continuer √† tirer
          console.log(`Cliquez sur le deck pour tirer vos cartes (${nbCartes + 1}/3)`);
          
          // R√©afficher l'indicateur pour la carte centrale
          setTimeout(() => {
            afficherIndicateurZone('center');
          }, 500);
        }
      }
    }
    
    function joueurJoueCarte(index) {
      if (index < gameState.mainJoueur.length) {
        gameState.carteJoueeJoueur = gameState.mainJoueur[index];
        gameState.mainJoueur.splice(index, 1);
        afficherCartes();
        
        gameState.waitingForPlayerAction = false;
        
        // Si adversaire n'a pas encore jou√©, il joue maintenant
        if (!gameState.carteJoueeAdversaire) {
          setTimeout(() => {
            adversaireJoueCarte();
            resoudreTour();
          }, 500);
        } else {
          // Sinon r√©soudre directement
          resoudreTour();
        }
      }
    }
    
    function adversaireJoueCarte() {
      console.log("Adversaire joue une carte...");
      
      if (gameState.mainAdversaire.length === 0) {
        console.error("Adversaire n'a pas de cartes!");
        return;
      }
      
      // Strat√©gie simple : essayer de gagner ou faire √©galit√©
      let bestIndex = 0;
      
      if (gameState.carteJoueeJoueur) {
        // Adversaire r√©pond √† la carte du joueur
        let bestScore = -1;
        for (let i = 0; i < gameState.mainAdversaire.length; i++) {
          const score = evaluerCarte(gameState.mainAdversaire[i], gameState.carteJoueeJoueur);
          if (score > bestScore) {
            bestScore = score;
            bestIndex = i;
          }
        }
        console.log(`Adversaire choisit la carte ${bestIndex + 1} (score: ${bestScore})`);
      } else {
        // Adversaire joue en premier, choix al√©atoire
        bestIndex = Math.floor(Math.random() * gameState.mainAdversaire.length);
        console.log(`Adversaire choisit la carte ${bestIndex + 1} (al√©atoire)`);
      }
      
      gameState.carteJoueeAdversaire = gameState.mainAdversaire[bestIndex];
      gameState.mainAdversaire.splice(bestIndex, 1);
      
      console.log(`Adversaire joue: ${gameState.carteJoueeAdversaire.nom}`);
      
      afficherCartes();
    }
    
    function evaluerCarte(carteAttaquant, carteDefenseur) {
      const nomDefenseur = carteDefenseur.nom;
      const key = `vs${nomDefenseur}`;
      return carteAttaquant[key] || 0;
    }
    
    function resoudreTour() {
      if (!gameState.carteJoueeJoueur || !gameState.carteJoueeAdversaire) return;
      
      const scoreJoueur = evaluerCarte(gameState.carteJoueeJoueur, gameState.carteJoueeAdversaire);
      const scoreAdversaire = evaluerCarte(gameState.carteJoueeAdversaire, gameState.carteJoueeJoueur);
      
      let resultat = "";
      let gainPerte = 0;
      
      // VICTOIRE si le joueur a un meilleur score
      if (scoreJoueur > scoreAdversaire) {
        resultat = "VICTOIRE";
        gainPerte = gameState.carteJoueeJoueur.occurrence;
        heuresEnquete += gainPerte;
        console.log(`Joueur gagne avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      } 
      // D√âFAITE si l'adversaire a un meilleur score
      else if (scoreAdversaire > scoreJoueur) {
        resultat = "D√âFAITE";
        gainPerte = -gameState.carteJoueeAdversaire.occurrence;
        heuresEnquete += gainPerte;
        console.log(`Joueur perd avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      } 
      // √âGALIT√â si scores identiques
      else {
        resultat = "√âGALIT√â";
        console.log(`√âgalit√© avec ${gameState.carteJoueeJoueur.nom} (${scoreJoueur}) vs ${gameState.carteJoueeAdversaire.nom} (${scoreAdversaire})`);
      }
      
      // Ajouter au total de la confrontation
      pointsGagnesConfrontation += gainPerte;
      
      console.log(`${resultat} - ${gainPerte > 0 ? '+' : ''}${gainPerte} Heures d'Enqu√™te`);
      
      // Afficher le r√©sultat avec animation
      const resultDisplay = document.getElementById('result-display');
      resultDisplay.textContent = resultat;
      resultDisplay.className = 'show';
      
      // Couleur selon le r√©sultat
      if (resultat === "VICTOIRE") {
        resultDisplay.style.color = '#2ecc71';
      } else if (resultat === "D√âFAITE") {
        resultDisplay.style.color = '#e74c3c';
      } else {
        resultDisplay.style.color = '#f39c12';
      }
      
      updateGaugesDisplay();
      
      // Afficher les points gagn√©s/perdus pour ce tour
      if (gainPerte !== 0) {
        setTimeout(() => {
          afficherPointsGagnes(gainPerte);
        }, 1500);
      }
      
      // Passer au tour suivant ou terminer
      setTimeout(() => {
        resultDisplay.classList.remove('show');
        
        setTimeout(() => {
          if (gameState.currentTurn >= 2) {
            terminerMiniJeu();
          } else {
            // Tour suivant avec initiative invers√©e
            if (gameState.playerHasInitiative) {
              demarrerTourAdversaireInitiative();
            } else {
              demarrerTourJoueurInitiative();
            }
          }
        }, 300);
      }, 2000);
    }
    
    function terminerMiniJeu() {
      console.log("=== FIN DU MINI-JEU ===");
      gameState.isGameActive = false;
      clearCardsDisplay();
      
      // Afficher le total des points gagn√©s/perdus pendant la confrontation
      if (pointsGagnesConfrontation !== 0) {
        setTimeout(() => {
          afficherPointsGagnes(pointsGagnesConfrontation, true);
        }, 500);
      }
      
      // Masquer le bouton "Next Page" et afficher le bouton "Refermer"
      setTimeout(() => {
        const nextPageBtn = document.getElementById('next-page-btn');
        const closeBtn = document.getElementById('close-confrontation-btn');
        
        nextPageBtn.style.display = 'none';
        nextPageBtn.style.pointerEvents = 'none';
        
        closeBtn.classList.add('visible');
        
        console.log("Cliquez sur 'Refermer' pour terminer la confrontation");
      }, pointsGagnesConfrontation !== 0 ? 2500 : 0);
    }
    
    function reinitialiserMiniJeu() {
      console.log("R√©initialisation du mini-jeu de cartes");
      
      // Masquer le tableau de cartes
      const cardsContainer = document.getElementById('cards-game-container');
      cardsContainer.classList.remove('visible');
      
      // Masquer l'affichage du r√©sultat
      const resultDisplay = document.getElementById('result-display');
      resultDisplay.classList.remove('show');
      resultDisplay.textContent = '';
      
      // R√©afficher le bouton "Next Page" et masquer le bouton "Refermer"
      const nextPageBtn = document.getElementById('next-page-btn');
      const closeBtn = document.getElementById('close-confrontation-btn');
      
      nextPageBtn.style.display = 'inline-block';
      nextPageBtn.style.pointerEvents = 'auto';
      
      closeBtn.classList.remove('visible');
      
      // R√©initialiser l'√©tat du jeu
      gameState.isGameActive = false;
      gameState.currentTurn = 0;
      gameState.playerHasInitiative = false;
      gameState.deckJoueur = [];
      gameState.deckAdversaire = [];
      gameState.mainJoueur = [];
      gameState.mainAdversaire = [];
      gameState.carteJoueeJoueur = null;
      gameState.carteJoueeAdversaire = null;
      gameState.waitingForPlayerAction = false;
      gameState.actionType = null;
      
      // R√©initialiser la page de dialogue
      currentDialoguePage = 0;
      
      // Effacer compl√®tement l'affichage des cartes
      clearCardsDisplay();
      
      // Nettoyer la case centrale
      const centerCard = document.getElementById('card-center');
      centerCard.textContent = '';
      centerCard.style.fontSize = '';
      centerCard.style.color = '';
      centerCard.style.display = '';
      centerCard.style.visibility = 'hidden';
      centerCard.style.backgroundImage = 'none';
      centerCard.style.backgroundColor = '';
      
      console.log("Mini-jeu r√©initialis√© et pr√™t pour la prochaine confrontation");
    }
    
    function afficherIndicateurZone(zone) {
      gameState.isPaused = true; // Mettre le jeu en pause
      
      const indicator = document.getElementById('click-indicator');
      const confrontationPanel = document.getElementById('confrontation-panel');
      
      let indicatorStyle = {};
      
      if (zone === 'center') {
        // Indicateur sur la carte centrale
        const centerCard = document.getElementById('card-center');
        const cardRect = centerCard.getBoundingClientRect();
        const panelRect = confrontationPanel.getBoundingClientRect();
        
        indicatorStyle = {
          left: (cardRect.left - panelRect.left - 5) + 'px',
          top: (cardRect.top - panelRect.top - 5) + 'px',
          width: (cardRect.width + 10) + 'px',
          height: (cardRect.height + 10) + 'px'
        };
      } else if (zone === 'player-hand') {
        // Indicateur sur toute la ligne du haut (main du joueur)
        const firstCard = document.getElementById('card-player-1');
        const lastCard = document.getElementById('card-player-3');
        const firstRect = firstCard.getBoundingClientRect();
        const lastRect = lastCard.getBoundingClientRect();
        const panelRect = confrontationPanel.getBoundingClientRect();
        
        indicatorStyle = {
          left: (firstRect.left - panelRect.left - 5) + 'px',
          top: (firstRect.top - panelRect.top - 5) + 'px',
          width: (lastRect.right - firstRect.left + 10) + 'px',
          height: (firstRect.height + 10) + 'px'
        };
      }
      
      // Appliquer les styles
      Object.assign(indicator.style, indicatorStyle);
      indicator.classList.add('show');
      
      // Masquer apr√®s 800ms et reprendre le jeu
      setTimeout(() => {
        indicator.classList.remove('show');
        gameState.isPaused = false; // Reprendre le jeu
      }, 800);
    }
    
    function afficherPointsGagnes(points, isTotal = false) {
      const pointsDisplay = document.getElementById('points-display');
      
      console.log(`Affichage des points: ${points} (Total: ${isTotal})`);
      
      // Texte selon le contexte
      let texte = '';
      if (isTotal) {
        texte = points > 0 ? `+${points} Heures d'Enqu√™te` : `${points} Heures d'Enqu√™te`;
      } else {
        texte = points > 0 ? `+${points}` : `${points}`;
      }
      
      pointsDisplay.textContent = texte;
      
      // Couleur selon gain ou perte
      if (points > 0) {
        pointsDisplay.style.color = '#2ecc71'; // Vert pour gain
      } else if (points < 0) {
        pointsDisplay.style.color = '#e74c3c'; // Rouge pour perte
      } else {
        pointsDisplay.style.color = '#f39c12'; // Orange pour z√©ro
      }
      
      // S'assurer que l'√©l√©ment est visible
      pointsDisplay.style.display = 'block';
      
      // R√©initialiser l'animation en enlevant puis rajoutant la classe
      pointsDisplay.classList.remove('show');
      
      // Force un reflow pour red√©marrer l'animation
      void pointsDisplay.offsetWidth;
      
      // Afficher avec animation
      pointsDisplay.classList.add('show');
      
      console.log("Points affich√©s!");
      
      // Masquer apr√®s 2 secondes
      setTimeout(() => {
        pointsDisplay.classList.remove('show');
        setTimeout(() => {
          pointsDisplay.style.display = 'none';
        }, 300);
      }, 2000);
    }
    
    function calculateAccessibleCells(fromRow, fromCol, range) {
      // Calculer les cases accessibles depuis une position donn√©e avec un range
      const accessible = [];
      const visited = new Set();
      const queue = [{ row: fromRow, col: fromCol, distance: 0 }];
      
      visited.add(`${fromRow}-${fromCol}`);
      
      // Ajouter la case de d√©part comme accessible (distance 0)
      accessible.push({ row: fromRow, col: fromCol, distance: 0 });
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.distance >= range) continue;
        
        // V√©rifier les 4 directions (haut, bas, gauche, droite)
        const directions = [
          { dr: -1, dc: 0 },  // Haut
          { dr: 1, dc: 0 },   // Bas
          { dr: 0, dc: -1 },  // Gauche
          { dr: 0, dc: 1 }    // Droite
        ];
        
        for (const dir of directions) {
          const newRow = current.row + dir.dr;
          const newCol = current.col + dir.dc;
          const key = `${newRow}-${newCol}`;
          
          // V√©rifier les limites et si la case est une route
          if (newRow >= 0 && newRow < boardSize && 
              newCol >= 0 && newCol < boardSize && 
              cityMap[newRow][newCol] && 
              !visited.has(key)) {
            
            visited.add(key);
            
            // V√©rifier si la case n'est pas occup√©e par un autre pion
            const isOccupied = pions.some(p => 
              p !== redPion && p.userData.row === newRow && p.userData.col === newCol
            );
            
            if (!isOccupied) {
              accessible.push({ row: newRow, col: newCol, distance: current.distance + 1 });
              queue.push({ row: newRow, col: newCol, distance: current.distance + 1 });
            }
          }
        }
      }
      
      return accessible;
    }
    
    function highlightAccessibleCells() {
      // Retirer la surbrillance de toutes les cases
      clearHighlights();
      
      if (!redPion) return;
      
      // Calculer les cases accessibles
      accessibleCells = calculateAccessibleCells(
        redPion.userData.row, 
        redPion.userData.col, 
        moveRange
      );
      
      // Mettre en surbrillance les cases accessibles
      accessibleCells.forEach(cell => {
        const key = `${cell.row}-${cell.col}`;
        const square = squareMeshes[key];
        if (square) {
          square.material.color.setHex(0xffff99); // Jaune clair
        }
      });
    }
    
    function clearHighlights() {
      // Restaurer la couleur originale de toutes les cases
      for (const key in squareMeshes) {
        const square = squareMeshes[key];
        square.material.color.setHex(square.userData.originalColor);
      }
    }
    
    function startPlayerTurn() {
      isPlayerTurn = true;
      
      // M√©moriser la position de d√©part du tour
      if (redPion) {
        startTurnPosition = { row: redPion.userData.row, col: redPion.userData.col };
      }
      
      highlightAccessibleCells();
      updateGaugesDisplay();
      
      console.log("=== Tour du joueur ===");
      console.log(`Heures d'Enqu√™te: ${heuresEnquete}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log("D√©placez-vous dans les cases surlign√©es, puis appuyez sur la flamme");
    }
    
    function endPlayerTurn() {
      isPlayerTurn = false;
      clearHighlights();
      
      // Calculer la distance parcourue pendant ce tour
      if (redPion) {
        const distanceTraveled = Math.abs(redPion.userData.row - startTurnPosition.row) + 
                                  Math.abs(redPion.userData.col - startTurnPosition.col);
        
        // Soustraire les heures d'enqu√™te
        heuresEnquete -= distanceTraveled;
        console.log(`Distance parcourue: ${distanceTraveled} cases`);
        console.log(`Heures d'Enqu√™te restantes: ${heuresEnquete}`);
        
        // Mettre √† jour l'affichage
        updateGaugesDisplay();
        
        // V√©rifier si le joueur a perdu (plus d'heures d'enqu√™te)
        if (heuresEnquete <= 0) {
          gameOver();
          return;
        }
      }
      
      console.log("Tour de l'adversaire");
      
      // V√©rifier s'il y a un pion adverse adjacent au pion rouge
      if (isEnemyAdjacentToRedPion()) {
        // D√©clencher la phase de confrontation
        openConfrontation();
      } else {
        // Continuer directement le tour de l'adversaire
        setTimeout(() => {
          aiTurn();
        }, 500);
      }
    }
    
    function gameOver() {
      console.log("=== VOUS AVEZ PERDU ===");
      console.log("Vos Heures d'Enqu√™te sont √©puis√©es!");
      alert("VOUS AVEZ PERDU\n\nVos Heures d'Enqu√™te sont √©puis√©es!\n\nCliquez sur 'Recommencer' pour rejouer.");
      isPlayerTurn = false;
    }
    
    function isEnemyAdjacentToRedPion() {
      if (!redPion) return false;
      
      const redRow = redPion.userData.row;
      const redCol = redPion.userData.col;
      
      // V√©rifier les 4 cases adjacentes (haut, bas, gauche, droite)
      const adjacentPositions = [
        { row: redRow - 1, col: redCol },     // Haut
        { row: redRow + 1, col: redCol },     // Bas
        { row: redRow, col: redCol - 1 },     // Gauche
        { row: redRow, col: redCol + 1 }      // Droite
      ];
      
      // V√©rifier si un pion adverse (pas le rouge) est sur une case adjacente
      for (const pos of adjacentPositions) {
        const enemyOnCell = pions.find(p => 
          p !== redPion && 
          p.userData.row === pos.row && 
          p.userData.col === pos.col
        );
        
        if (enemyOnCell) {
          console.log("Pion adverse adjacent d√©tect√© - Confrontation d√©clench√©e!");
          confrontedPion = enemyOnCell; // M√©moriser le pion confront√©
          return true;
        }
      }
      
      return false;
    }
    
    function openConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.add('active');
      
      // R√©initialiser le compteur de points de la confrontation
      pointsGagnesConfrontation = 0;
      
      // Incr√©menter le compteur de confrontations
      confrontationCount++;
      
      // Calculer les points d'alignement √† ajouter/soustraire (2, 4, 6, 8, 10, ...)
      const alignmentChange = confrontationCount * 2;
      
      // D√©terminer le type de pion confront√©
      let dialogueType = 'default';
      let pionColor = 'default';
      
      if (confrontedPion) {
        // Identifier le type bas√© sur l'index dans le tableau pionTypes
        const pionIndex = pions.indexOf(confrontedPion);
        if (pionIndex === 0) {
          dialogueType = 'default'; // Pion rouge (ne devrait pas arriver)
        } else if (pionIndex >= 1 && pionIndex <= 5) {
          dialogueType = 'green'; // Pions verts (indices 1-5)
          pionColor = 'green';
          // Confrontation avec un pion vert : on AJOUTE des points d'alignement
          pointsAlignement += alignmentChange;
          console.log(`+${alignmentChange} Points d'Alignement (confrontation avec pion vert)`);
        } else {
          dialogueType = 'purple'; // Pions violets (indices 6-8)
          pionColor = 'purple';
          // Confrontation avec un pion violet : on SOUSTRAIT des points d'alignement
          pointsAlignement -= alignmentChange;
          console.log(`-${alignmentChange} Points d'Alignement (confrontation avec pion violet)`);
        }
      }
      
      // Calculer les points de confrontation initiaux (6 de base)
      pointsConfrontation = 6;
      
      // Appliquer les bonus/malus selon l'alignement
      if (pointsAlignement > 0) {
        // Alignement positif : bonus avec violets, malus avec verts
        if (pionColor === 'green') {
          pointsConfrontation -= 3;
        } else if (pionColor === 'purple') {
          pointsConfrontation += 3;
        }
      } else if (pointsAlignement < 0) {
        // Alignement n√©gatif : bonus avec verts, malus avec violets
        if (pionColor === 'green') {
          pointsConfrontation += 3;
        } else if (pionColor === 'purple') {
          pointsConfrontation -= 3;
        }
      }
      
      console.log("=== CONFRONTATION ===");
      console.log(`Confrontation n¬∞${confrontationCount}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log(`Points de Confrontation: ${pointsConfrontation}`);
      
      // Mettre √† jour l'affichage
      updateGaugesDisplay();
      
      // R√©initialiser √† la premi√®re page
      currentDialoguePage = 0;
      updateDialogue(dialogueType);
      
      console.log("Phase Confrontation d√©clench√©e");
    }
    
    function updateDialogue(dialogueType) {
      const dialogue = dialogues[dialogueType] || dialogues.default;
      const nameElement = document.getElementById('character-name');
      const textElement = document.getElementById('dialogue-text');
      const nextBtn = document.getElementById('next-page-btn');
      
      // Mettre √† jour le nom
      nameElement.textContent = dialogue.name;
      
      // Mettre √† jour le texte de la page actuelle
      if (currentDialoguePage < dialogue.pages.length) {
        textElement.textContent = dialogue.pages[currentDialoguePage];
      }
      
      // Cacher le bouton "Next Page" si on est √† la derni√®re page
      if (currentDialoguePage >= dialogue.pages.length - 1) {
        nextBtn.style.display = 'none';
        // D√©marrer le mini-jeu quand le dialogue est termin√©
        if (!gameState.isGameActive) {
          setTimeout(() => {
            startCardGame();
          }, 500);
        }
      } else {
        nextBtn.style.display = 'inline-block';
      }
      
      // Stocker le type de dialogue pour le bouton Next Page
      nextBtn.dataset.dialogueType = dialogueType;
    }
    
    function closeConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.remove('active');
      console.log("Phase Confrontation termin√©e");
      
      // Regagner 5 heures d'enqu√™te apr√®s une confrontation
      heuresEnquete += 5;
      console.log(`+5 Heures d'Enqu√™te (r√©compense de confrontation)`);
      console.log(`Heures d'Enqu√™te: ${heuresEnquete}`);
      
      // Replacer le pion confront√© ailleurs sur l'√©chiquier
      if (confrontedPion) {
        relocateConfrontedPion(confrontedPion);
        confrontedPion = null; // R√©initialiser
      }
      
      // R√©initialiser les points de confrontation √† z√©ro
      pointsConfrontation = 0;
      console.log(`Points de Confrontation r√©initialis√©s: ${pointsConfrontation}`);
      
      // R√©initialiser le mini-jeu de cartes
      reinitialiserMiniJeu();
      
      // Mettre √† jour l'affichage
      updateGaugesDisplay();
      
      // Continuer le tour de l'adversaire apr√®s la fermeture
      setTimeout(() => {
        aiTurn();
      }, 500);
    }
    
    function relocateConfrontedPion(pion) {
      // Trouver une case route libre (non occup√©e par un autre pion)
      const freeCells = roadPositions.filter(road => {
        // V√©rifier qu'aucun pion n'occupe cette case
        const isOccupied = pions.some(p => 
          p.userData.row === road.row && p.userData.col === road.col
        );
        return !isOccupied;
      });
      
      if (freeCells.length > 0) {
        // Choisir une case al√©atoire parmi les cases libres
        const newCell = freeCells[Math.floor(Math.random() * freeCells.length)];
        movePion(pion, newCell.row, newCell.col);
        console.log(`Pion confront√© replac√© √† la position (${newCell.row}, ${newCell.col})`);
      } else {
        console.log("Aucune case libre disponible pour replacer le pion confront√©");
      }
    }
    
    function aiTurn() {
      // L'IA choisit un pion au hasard (pas le rouge) et le d√©place
      const aiPions = pions.filter(p => p !== redPion);
      if (aiPions.length === 0) {
        startPlayerTurn();
        return;
      }
      
      const selectedPion = aiPions[Math.floor(Math.random() * aiPions.length)];
      const aiAccessible = calculateAccessibleCells(
        selectedPion.userData.row,
        selectedPion.userData.col,
        moveRange
      );
      
      if (aiAccessible.length > 0) {
        const targetCell = aiAccessible[Math.floor(Math.random() * aiAccessible.length)];
        movePion(selectedPion, targetCell.row, targetCell.col);
      }
      
      // Retour au tour du joueur
      setTimeout(() => {
        startPlayerTurn();
      }, 500);
    }
    
    function movePion(pion, toRow, toCol) {
      // D√©placer un pion vers une nouvelle case
      pion.userData.row = toRow;
      pion.userData.col = toCol;
      
      const x = (toCol - (boardSize - 1) / 2) * squareSize;
      const z = (toRow - (boardSize - 1) / 2) * squareSize;
      
      pion.userData.baseX = x;
      pion.userData.baseZ = z;
      
      const pionHeight = pion.scale.y;
      pion.position.set(x, pionHeight / 2, z);
    }
    
    function createPionTexture(color) {
      // Cr√©er une texture pour un pion d'une couleur donn√©e
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      
      // Fond transparent
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner un pion simple (cercle + base)
      // Positionner pour que le bas de l'image soit le point d'ancrage
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(64, 50, 40, 0, Math.PI * 2);
      ctx.fill();
      
      // Base plus fonc√©e
      const darkColor = shadeColor(color, -30);
      ctx.fillStyle = darkColor;
      ctx.fillRect(50, 90, 28, 60);
      ctx.beginPath();
      ctx.ellipse(64, 150, 25, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function shadeColor(color, percent) {
      // Fonction pour assombrir une couleur
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
        (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
        .toString(16).slice(1);
    }
    
    function createAllPions() {
      // Supprimer tous les anciens pions
      pions.forEach(p => checkerboard.remove(p));
      pions = [];
      redPion = null;
      
      // Cr√©er un ensemble pour suivre les cases occup√©es
      const occupiedPositions = new Set();
      
      // S'assurer qu'il y a assez de routes pour tous les pions
      if (roadPositions.length < 9) {
        console.error("Pas assez de routes pour placer tous les pions!");
        return;
      }
      
      // Cr√©er chaque type de pion
      pionTypes.forEach((type, typeIndex) => {
        for (let i = 0; i < type.count; i++) {
          // Trouver une position al√©atoire libre sur une route
          let roadIndex, position, posKey;
          let attempts = 0;
          do {
            roadIndex = Math.floor(Math.random() * roadPositions.length);
            position = roadPositions[roadIndex];
            posKey = `${position.row}-${position.col}`;
            attempts++;
            if (attempts > 1000) {
              console.error("Impossible de trouver une position libre!");
              return;
            }
          } while (occupiedPositions.has(posKey));
          
          occupiedPositions.add(posKey);
          
          // Cr√©er le pion
          const texture = createPionTexture(type.color);
          const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true
          });
          
          const pion = new THREE.Sprite(material);
          const pionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const pionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pion.scale.set(pionScale, pionHeight, 1);
          
          // Positionner le pion sur la case
          // Le centre du bas de l'image doit √™tre au centre de la case
          const x = (position.col - (boardSize - 1) / 2) * squareSize;
          const z = (position.row - (boardSize - 1) / 2) * squareSize;
          // D√©calage vertical : la moiti√© de la hauteur du sprite pour que le bas soit sur la case
          pion.position.set(x, pionHeight / 2, z);
          
          // Stocker les coordonn√©es du pion et sa position de base
          pion.userData = { 
            row: position.row, 
            col: position.col,
            baseX: x,
            baseZ: z
          };
          
          checkerboard.add(pion);
          pions.push(pion);
          
          // Garder une r√©f√©rence au pion rouge (premier pion du premier type)
          if (typeIndex === 0 && i === 0) {
            redPion = pion;
          }
        }
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Animation de rotation progressive
      if (isRotating) {
        const diff = targetRotation - checkerboard.rotation.y;
        if (Math.abs(diff) > 0.01) {
          checkerboard.rotation.y += diff * 0.1;
          
          // Faire pivoter la skysphere en synchronisation avec le damier
          if (skysphere) {
            skysphere.rotation.y = checkerboard.rotation.y + Math.PI / 4; // +45¬∞ pour l'alignement initial
          }
          
          // Si on est zoom√©, mettre √† jour la position de la cam√©ra pour suivre le pion rouge
          if (isZoomed && redPion) {
            const redPionWorldPos = new THREE.Vector3();
            redPion.getWorldPosition(redPionWorldPos);
            
            targetCameraPos = {
              x: redPionWorldPos.x,
              y: 3,
              z: redPionWorldPos.z + 2.5
            };
            targetCameraLookAt = {
              x: redPionWorldPos.x,
              y: 0,
              z: redPionWorldPos.z
            };
            
            camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
            camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          }
        } else {
          checkerboard.rotation.y = targetRotation;
          if (skysphere) {
            skysphere.rotation.y = targetRotation + Math.PI / 4;
          }
          isRotating = false;
        }
      }
      
      // Animation de zoom progressive
      if (isZooming) {
        const posXDiff = targetCameraPos.x - camera.position.x;
        const posYDiff = targetCameraPos.y - camera.position.y;
        const posZDiff = targetCameraPos.z - camera.position.z;
        
        if (Math.abs(posXDiff) > 0.01 || Math.abs(posYDiff) > 0.01 || Math.abs(posZDiff) > 0.01) {
          camera.position.x += posXDiff * 0.1;
          camera.position.y += posYDiff * 0.1;
          camera.position.z += posZDiff * 0.1;
          
          // Mettre √† jour la cible de la cam√©ra
          const lookAtX = targetCameraLookAt.x;
          const lookAtY = targetCameraLookAt.y;
          const lookAtZ = targetCameraLookAt.z;
          camera.lookAt(lookAtX, lookAtY, lookAtZ);
          
          // Mettre √† jour la taille des pions progressivement
          const zoomProgress = isZoomed ? 
            1 - Math.abs(posYDiff) / (12 - 3) : 
            Math.abs(posYDiff) / (12 - 3);
          const pionScale = squareSize * (0.8 + zoomProgress * 1.2);
          const pionHeight = squareSize * (1.1 + zoomProgress * 1.4);
          
          pions.forEach(p => {
            p.scale.set(pionScale, pionHeight, 1);
            // Maintenir le pion ancr√© au centre de sa case
            p.position.y = pionHeight / 2;
          });
        } else {
          camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
          camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          isZooming = false;
          
          // Fixer la taille finale des pions
          const finalPionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const finalPionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pions.forEach(p => {
            p.scale.set(finalPionScale, finalPionHeight, 1);
            // Maintenir le pion ancr√© au centre de sa case
            p.position.y = finalPionHeight / 2;
          });
        }
      }
      
      renderer.render(scene, camera);
    }
    
    // Gestionnaires des boutons Rotate
    document.getElementById('rotateRightBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation += Math.PI / 2; // +90 degr√©s
        currentRotationStep = (currentRotationStep + 1) % 4;
        updateDirectionMappings();
      }
    });
    
    document.getElementById('rotateLeftBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation -= Math.PI / 2; // -90 degr√©s
        currentRotationStep = (currentRotationStep - 1 + 4) % 4;
        updateDirectionMappings();
      }
    });
    
    document.getElementById('zoomBtn').addEventListener('click', function() {
      if (!isZooming && redPion) {
        isZooming = true;
        isZoomed = !isZoomed;
        
        if (isZoomed) {
          // Vue rapproch√©e : centrer sur le pion rouge
          const redPionWorldPos = new THREE.Vector3();
          redPion.getWorldPosition(redPionWorldPos);
          
          // Cam√©ra plus proche et plus horizontale
          targetCameraPos = {
            x: redPionWorldPos.x,
            y: 3,  // Beaucoup plus bas qu'avant (√©tait 12)
            z: redPionWorldPos.z + 2.5  // Plus proche
          };
          targetCameraLookAt = {
            x: redPionWorldPos.x,
            y: 0,
            z: redPionWorldPos.z
          };
          
          this.textContent = 'UnZoom';
        } else {
          // Vue g√©n√©rale
          targetCameraPos = { x: 0, y: 12, z: 10 };
          targetCameraLookAt = { x: 0, y: 0, z: 0 };
          
          this.textContent = 'Zoom';
        }
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', function() {
      // R√©initialiser les jauges de points
      heuresEnquete = 15;
      pointsConfrontation = 0;
      pointsAlignement = 0;
      confrontationCount = 0;
      currentRotationStep = 0;
      
      console.log("=== JEU R√âINITIALIS√â ===");
      console.log(`Heures d'Enqu√™te: ${heuresEnquete}`);
      console.log(`Points d'Alignement: ${pointsAlignement}`);
      console.log(`Confrontations: ${confrontationCount}`);
      
      // Mettre √† jour l'affichage
      updateGaugesDisplay();
      
      // R√©g√©n√©rer le r√©seau routier
      checkerboard.clear();
      
      // R√©g√©n√©rer le damier avec un nouveau plan
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // V√©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // D√©terminer si c'est une route ou un b√¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }
      
      // Cr√©er les nouveaux pions
      createAllPions();
      
      // R√©initialiser le zoom si on √©tait zoom√©
      if (isZoomed) {
        isZoomed = false;
        isZooming = false;
        camera.position.set(0, 12, 10);
        camera.lookAt(0, 0, 0);
        targetCameraPos = { x: 0, y: 12, z: 10 };
        targetCameraLookAt = { x: 0, y: 0, z: 0 };
        document.getElementById('zoomBtn').textContent = 'Zoom';
      }
      
      // Red√©marrer le tour du joueur
      startPlayerTurn();
    });
    
    // Gestionnaires pour la croix directionnelle
    document.getElementById('dpad-UR').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('UR');
      }
    });
    
    document.getElementById('dpad-BR').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('BR');
      }
    });
    
    document.getElementById('dpad-BL').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('BL');
      }
    });
    
    document.getElementById('dpad-UL').addEventListener('click', function() {
      if (isPlayerTurn) {
        executeDirection('UL');
      }
    });
    
    // Fonctions de d√©placement absolues (relatives √† la grille)
    function moveUp() {
      movePlayerOneStep(-1, 0); // row--
    }
    
    function moveRight() {
      movePlayerOneStep(0, 1); // col++
    }
    
    function moveDown() {
      movePlayerOneStep(1, 0); // row++
    }
    
    function moveLeft() {
      movePlayerOneStep(0, -1); // col--
    }
    
    // Mapping des boutons aux fonctions selon la rotation
    let directionMappings = {
      'UR': moveUp,
      'BR': moveRight,
      'BL': moveDown,
      'UL': moveLeft
    };
    
    function updateDirectionMappings() {
      // R√©affecter les fonctions selon la rotation actuelle
      // currentRotationStep: 0=0¬∞, 1=90¬∞, 2=180¬∞, 3=270¬∞
      
      switch(currentRotationStep) {
        case 0: // 0¬∞ - orientation initiale
          directionMappings = {
            'UR': moveUp,
            'BR': moveRight,
            'BL': moveDown,
            'UL': moveLeft
          };
          break;
        case 1: // 90¬∞ rotation droite
          directionMappings = {
            'UR': moveRight,
            'BR': moveDown,
            'BL': moveLeft,
            'UL': moveUp
          };
          break;
        case 2: // 180¬∞
          directionMappings = {
            'UR': moveDown,
            'BR': moveLeft,
            'BL': moveUp,
            'UL': moveRight
          };
          break;
        case 3: // 270¬∞ (ou -90¬∞)
          directionMappings = {
            'UR': moveLeft,
            'BR': moveUp,
            'BL': moveRight,
            'UL': moveDown
          };
          break;
      }
      
      console.log(`Direction mappings updated for rotation step ${currentRotationStep}`);
    }
    
    function executeDirection(buttonId) {
      const directionFunction = directionMappings[buttonId];
      if (directionFunction) {
        directionFunction();
      }
    }
    
    function movePlayerOneStep(deltaRow, deltaCol) {
      if (!redPion || !isPlayerTurn) return;
      
      // Calculer la case cible (une seule case de distance)
      const targetRow = redPion.userData.row + deltaRow;
      const targetCol = redPion.userData.col + deltaCol;
      
      // V√©rifier si la case cible est dans les cases accessibles
      const isAccessible = accessibleCells.some(cell => 
        cell.row === targetRow && cell.col === targetCol
      );
      
      if (isAccessible) {
        movePion(redPion, targetRow, targetCol);
        console.log("Pion d√©plac√© - Continuez ou appuyez sur la flamme pour terminer votre tour");
      } else {
        console.log("Case non accessible");
      }
    }
    
    document.getElementById('dpad-center').addEventListener('click', function() {
      console.log('Action: Flamme - Fin du tour du joueur');
      // Terminer le tour du joueur
      if (isPlayerTurn) {
        endPlayerTurn();
      }
    });
    
    // Gestionnaire pour le bouton de fermeture de la confrontation
    document.getElementById('close-confrontation-btn').addEventListener('click', function() {
      closeConfrontation();
    });
    
    // Gestionnaire pour le bouton Next Page
    document.getElementById('next-page-btn').addEventListener('click', function() {
      currentDialoguePage++;
      const dialogueType = this.dataset.dialogueType || 'default';
      updateDialogue(dialogueType);
    });
    
    // Gestionnaires pour les cartes
    document.getElementById('card-center').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "draw" && !gameState.isPaused) {
        joueurTireCarte();
      }
    });
    
    document.getElementById('card-player-1').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(0);
      }
    });
    
    document.getElementById('card-player-2').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(1);
      }
    });
    
    document.getElementById('card-player-3').addEventListener('click', function() {
      if (gameState.waitingForPlayerAction && gameState.actionType === "play" && !gameState.isPaused) {
        joueurJoueCarte(2);
      }
    });
    
    init();
  </script>
</body>
</html>