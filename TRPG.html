<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube 3D</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      position: relative;
    }
    
    #container {
      width: 600px;
      height: 600px;
      background-color: #ffffff;
      border: 2px solid #ccc;
      margin-bottom: 20px;
      position: relative;
    }
    
    #controls {
      display: flex;
      gap: 20px;
    }
    
    button {
      padding: 15px 30px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:active {
      background-color: #3d8b40;
    }
    
    /* Croix directionnelle */
    #dpad-container {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 140px;
      height: 140px;
    }
    
    .dpad-button {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: #555;
      border: 2px solid #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      transition: background-color 0.2s, transform 0.1s;
      transform: rotate(0deg);
      user-select: none;
    }
    
    .dpad-button:hover {
      background-color: #666;
    }
    
    .dpad-button:active {
      background-color: #777;
      transform: rotate(0deg) scale(0.95);
    }
    
    .dpad-button span {
      transform: rotate(0deg);
      display: block;
    }
    
    #dpad-UR {
      top: 7%;
      left: 7%;
      transform: translate(0%, 0%) rotate(0deg);
    }
    
    #dpad-BR {
      top: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-UL {
      bottom: 7%;
      left: 7%;
      transform: translateX(0%, 0%)  rotate(0deg);
    }
    
    #dpad-BL {
      bottom: 7%;
      right: 7%;
      transform: translate(0%, 0%)  rotate(0deg);
    }
    
    #dpad-center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(45deg);
      background-color: #d35400;
      border-color: #a04000;
    }
    
    #dpad-center:hover {
      background-color: #e67e22;
    }
    
    #dpad-center:active {
      background-color: #ca6f1e;
      transform: translate(-50%, -50%) rotate(45deg) scale(0.95);
    }
    
    /* Volet de confrontation */
    #confrontation-panel {
      position: fixed;
      top: 0;
      right: -100%;
      width: 100%;
      height: 100%;
      background-image: url('background-image.png');
      background-size: cover;
      background-position: center;
      background-color: #2c3e50;
      transition: right 0.5s ease-in-out;
      z-index: 1000;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      padding: 30px;
    }
    
    #confrontation-panel.active {
      right: 0;
    }
    
    #close-confrontation-btn {
      padding: 15px 30px;
      font-size: 18px;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    #close-confrontation-btn:hover {
      background-color: #c0392b;
    }
    
    #close-confrontation-btn:active {
      background-color: #a93226;
    }
  </style>
</head>
<body>
  <!-- Volet de confrontation -->
  <div id="confrontation-panel">
    <button id="close-confrontation-btn">Refermer</button>
  </div>
  
  <div id="container">
    <!-- Croix directionnelle en X -->
    <div id="dpad-container">
      <div class="dpad-button" id="dpad-UR">
        <span>‚áñ</span>
      </div>
      <div class="dpad-button" id="dpad-BR">
        <span>‚áó</span>
      </div>
      <div class="dpad-button" id="dpad-BL">
        <span>‚áò</span>
      </div>
      <div class="dpad-button" id="dpad-UL">
        <span>‚áô</span>
      </div>
      <div class="dpad-button" id="dpad-center">
        <span>üî•</span>
      </div>
    </div>
  </div>
  <div id="controls">
    <button id="rotateLeftBtn">Rotate -90¬∞</button>
    <button id="rotateRightBtn">Rotate 90¬∞</button>
    <button id="zoomBtn">Zoom</button>
    <button id="resetBtn">Recommencer</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, checkerboard;
    let pions = []; // Tableau pour stocker tous les pions
    let redPion = null; // R√©f√©rence au pion rouge
    let isRotating = false;
    let targetRotation = 0;
    let isZoomed = false;
    let isZooming = false;
    let targetCameraPos = { x: 0, y: 12, z: 10 };
    let targetCameraLookAt = { x: 0, y: 0, z: 0 };
    const boardSize = 15;
    const squareSize = 0.6;
    const pionTypes = [
      { color: '#ff0000', count: 1 },  // 1 pion rouge
      { color: '#00ff00', count: 5 },  // 5 pions verts
      { color: '#9900ff', count: 3 }   // 3 pions violets
    ];
    let roadPositions = []; // Liste des positions de routes (cases gris clair)
    let cityMap = []; // Carte de la ville
    let squareMeshes = {}; // Dictionnaire pour acc√©der aux meshes des cases
    let accessibleCells = []; // Cases accessibles au pion rouge
    let isPlayerTurn = true; // Tour du joueur
    let confrontedPion = null; // Pion qui a d√©clench√© la confrontation
    const moveRange = 3; // Range de d√©placement
    
    function init() {
      // Cr√©er la sc√®ne
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      
      // Cr√©er la cam√©ra (vue en trois-quarts plong√©e avec face sup√©rieure horizontale)
      camera = new THREE.PerspectiveCamera(
        50,
        1,
        0.1,
        1000
      );
      camera.position.set(0, 12, 10);
      camera.lookAt(0, 0, 0);
      
      // Cr√©er le renderer
      const container = document.getElementById('container');
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(600, 600);
      container.insertBefore(renderer.domElement, container.firstChild);
      
      // Cr√©er le damier 15x15
      checkerboard = new THREE.Group();
      
      // G√©n√©rer le r√©seau routier
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // V√©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // D√©terminer si c'est une route ou un b√¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444 // Gris clair pour routes, gris fonc√© pour b√¢timents
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }
      
      // Rotation initiale √† +45¬∞ pour pr√©senter un coin face cam√©ra
      checkerboard.rotation.y = Math.PI / 4; // 45 degr√©s
      targetRotation = checkerboard.rotation.y;
      
      scene.add(checkerboard);
      
      // Cr√©er tous les pions
      createAllPions();
      
      // D√©marrer le tour du joueur
      startPlayerTurn();
      
      animate();
    }
    
    function generateCityMap() {
      // Cr√©er une grille initiale remplie de b√¢timents (false)
      const map = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      // Liste de toutes les positions des routes
      const roadCells = [];
      
      // Commencer au centre
      let currentRow = Math.floor(boardSize / 2);
      let currentCol = Math.floor(boardSize / 2);
      map[currentRow][currentCol] = true;
      roadCells.push({ row: currentRow, col: currentCol });
      
      const numSegments = 18 + Math.floor(Math.random() * 8); // 18-25 tron√ßons pour mieux couvrir
      
      for (let segment = 0; segment < numSegments; segment++) {
        // Choisir un point de d√©part parmi les routes existantes
        const startPoint = roadCells[Math.floor(Math.random() * roadCells.length)];
        currentRow = startPoint.row;
        currentCol = startPoint.col;
        
        // Choisir une direction al√©atoire (0: haut, 1: droite, 2: bas, 3: gauche)
        const direction = Math.floor(Math.random() * 4);
        // Longueur du tron√ßon (minimum 3 cases, maximum 6 cases)
        const length = 3 + Math.floor(Math.random() * 4);
        
        let deltaRow = 0, deltaCol = 0;
        if (direction === 0) deltaRow = -1; // Haut
        else if (direction === 1) deltaCol = 1; // Droite
        else if (direction === 2) deltaRow = 1; // Bas
        else if (direction === 3) deltaCol = -1; // Gauche
        
        // V√©rifier si le tron√ßon peut √™tre cr√©√© sans violer les r√®gles
        let canCreate = true;
        let tempRow = currentRow;
        let tempCol = currentCol;
        const newCells = [];
        
        for (let step = 0; step < length; step++) {
          tempRow += deltaRow;
          tempCol += deltaCol;
          
          // V√©rifier les limites
          if (tempRow < 0 || tempRow >= boardSize || 
              tempCol < 0 || tempCol >= boardSize) {
            canCreate = false;
            break;
          }
          
          newCells.push({ row: tempRow, col: tempCol });
          
          // V√©rifier qu'il n'y a pas de tron√ßons parall√®les coll√©s
          if (!canCreate) break;
          
          // Pour un tron√ßon horizontal (direction gauche/droite)
          if (direction === 1 || direction === 3) {
            // V√©rifier au-dessus et en-dessous
            if (tempRow > 0 && map[tempRow - 1][tempCol] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon horizontal parall√®le
              if ((tempCol > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow - 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempRow < boardSize - 1 && map[tempRow + 1][tempCol] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon horizontal parall√®le
              if ((tempCol > 0 && map[tempRow + 1][tempCol - 1]) || 
                  (tempCol < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
          
          // Pour un tron√ßon vertical (direction haut/bas)
          if (direction === 0 || direction === 2) {
            // V√©rifier √† gauche et √† droite
            if (tempCol > 0 && map[tempRow][tempCol - 1] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon vertical parall√®le
              if ((tempRow > 0 && map[tempRow - 1][tempCol - 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol - 1])) {
                canCreate = false;
                break;
              }
            }
            if (tempCol < boardSize - 1 && map[tempRow][tempCol + 1] && !map[tempRow][tempCol]) {
              // V√©rifier si c'est un tron√ßon vertical parall√®le
              if ((tempRow > 0 && map[tempRow - 1][tempCol + 1]) || 
                  (tempRow < boardSize - 1 && map[tempRow + 1][tempCol + 1])) {
                canCreate = false;
                break;
              }
            }
          }
        }
        
        // Cr√©er le tron√ßon seulement s'il est valide
        if (canCreate) {
          for (const cell of newCells) {
            if (!map[cell.row][cell.col]) {
              map[cell.row][cell.col] = true;
              roadCells.push(cell);
            }
          }
        }
      }
      
      // S'assurer que chaque zone 4x4 contient au moins une route
      for (let blockRow = 0; blockRow < boardSize - 3; blockRow += 4) {
        for (let blockCol = 0; blockCol < boardSize - 3; blockCol += 4) {
          let hasRoad = false;
          
          // V√©rifier si ce bloc 4x4 a au moins une route
          for (let r = blockRow; r < Math.min(blockRow + 4, boardSize); r++) {
            for (let c = blockCol; c < Math.min(blockCol + 4, boardSize); c++) {
              if (map[r][c]) {
                hasRoad = true;
                break;
              }
            }
            if (hasRoad) break;
          }
          
          // Si pas de route, en cr√©er une connect√©e au r√©seau le plus proche
          if (!hasRoad && roadCells.length > 0) {
            // Trouver la route la plus proche de ce bloc
            let closestRoad = null;
            let minDistance = Infinity;
            
            const blockCenterRow = blockRow + 1.5;
            const blockCenterCol = blockCol + 1.5;
            
            for (const road of roadCells) {
              const dist = Math.abs(road.row - blockCenterRow) + Math.abs(road.col - blockCenterCol);
              if (dist < minDistance) {
                minDistance = dist;
                closestRoad = road;
              }
            }
            
            // Cr√©er un chemin depuis la route la plus proche vers ce bloc
            if (closestRoad) {
              let pathRow = closestRoad.row;
              let pathCol = closestRoad.col;
              const targetRow = Math.floor(blockCenterRow);
              const targetCol = Math.floor(blockCenterCol);
              
              // Cr√©er un chemin simple (Manhattan)
              while (pathRow !== targetRow || pathCol !== targetCol) {
                if (pathRow < targetRow) pathRow++;
                else if (pathRow > targetRow) pathRow--;
                else if (pathCol < targetCol) pathCol++;
                else if (pathCol > targetCol) pathCol--;
                
                if (pathRow >= 0 && pathRow < boardSize && pathCol >= 0 && pathCol < boardSize) {
                  if (!map[pathRow][pathCol]) {
                    map[pathRow][pathCol] = true;
                    roadCells.push({ row: pathRow, col: pathCol });
                  }
                }
              }
            }
          }
        }
      }
      
      return map;
    }
    
    function addLandmarks(map) {
      // Ajouter des lieux dits : 8 rouges, 1 bleu, 1 vert
      const landmarks = [];
      const landmarkTypes = [
        { color: 0x8B0000, count: 8, type: 'red' },   // 8 cases rouge sombre
        { color: 0x00008B, count: 1, type: 'blue' },  // 1 case bleu sombre
        { color: 0x006400, count: 1, type: 'green' }  // 1 case vert sombre
      ];
      
      // Cr√©er un tableau pour marquer les positions des landmarks
      const landmarkMap = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
      
      for (const landmarkType of landmarkTypes) {
        for (let i = 0; i < landmarkType.count; i++) {
          let placed = false;
          let attempts = 0;
          
          while (!placed && attempts < 500) {
            attempts++;
            const row = Math.floor(Math.random() * boardSize);
            const col = Math.floor(Math.random() * boardSize);
            
            // V√©rifier que c'est un b√¢timent (pas une route)
            if (map[row][col] || landmarkMap[row][col]) continue;
            
            // V√©rifier qu'il y a au moins une route adjacente
            let hasAdjacentRoad = false;
            if (row > 0 && map[row - 1][col]) hasAdjacentRoad = true;
            if (row < boardSize - 1 && map[row + 1][col]) hasAdjacentRoad = true;
            if (col > 0 && map[row][col - 1]) hasAdjacentRoad = true;
            if (col < boardSize - 1 && map[row][col + 1]) hasAdjacentRoad = true;
            
            if (!hasAdjacentRoad) continue;
            
            // V√©rifier qu'aucun autre landmark n'est adjacent
            let hasAdjacentLandmark = false;
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                  if (landmarkMap[nr][nc]) {
                    hasAdjacentLandmark = true;
                    break;
                  }
                }
              }
              if (hasAdjacentLandmark) break;
            }
            
            if (hasAdjacentLandmark) continue;
            
            // Placer le landmark
            landmarkMap[row][col] = true;
            landmarks.push({ row, col, color: landmarkType.color, type: landmarkType.type });
            placed = true;
          }
        }
      }
      
      return landmarks;
    }
    
    function createBuilding(type, size) {
      // Cr√©er un groupe pour l'immeuble
      const building = new THREE.Group();
      
      // D√©terminer la couleur pastel et le nombre d'√©tages selon le type
      let color, floors;
      if (type === 'red') {
        color = 0xffb3ba; // Rose pastel
        floors = Math.random() < 0.5 ? 2 : 3; // 2 ou 3 √©tages
      } else if (type === 'blue') {
        color = 0xbae1ff; // Bleu pastel
        floors = 3;
      } else { // green
        color = 0xbaffc9; // Vert pastel
        floors = 3;
      }
      
      // Cr√©er les √©tages (cubes empil√©s)
      for (let i = 0; i < floors; i++) {
        const floorGeometry = new THREE.BoxGeometry(size, size, size);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: color });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        
        // Positionner chaque √©tage
        floor.position.y = 0.15 + size / 2 + i * size;
        
        // Ajouter des ar√™tes pour mieux voir la structure
        const edges = new THREE.EdgesGeometry(floorGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        floor.add(wireframe);
        
        building.add(floor);
      }
      
      // Ajouter un toit biseaut√© sur le dernier √©tage
      const roofHeight = size * 0.3;
      const roofGeometry = createBeveledRoofGeometry(size, roofHeight);
      const roofMaterial = new THREE.MeshBasicMaterial({ color: color });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      
      // Positionner le toit au-dessus du dernier √©tage
      roof.position.y = 0.15 + floors * size;
      
      // Ajouter des ar√™tes au toit
      const roofEdges = new THREE.EdgesGeometry(roofGeometry);
      const roofLineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
      const roofWireframe = new THREE.LineSegments(roofEdges, roofLineMaterial);
      roof.add(roofWireframe);
      
      building.add(roof);
      
      return building;
    }
    
    function createBeveledRoofGeometry(size, height) {
      // Cr√©er un toit biseaut√© (pyramide tronqu√©e sur une face)
      const shape = new THREE.Shape();
      
      // Base du toit (carr√©)
      const halfSize = size / 2;
      
      // Cr√©er une g√©om√©trie personnalis√©e pour le toit biseaut√©
      const geometry = new THREE.BufferGeometry();
      
      // D√©finir les sommets
      const vertices = new Float32Array([
        // Base (y = 0)
        -halfSize, 0, -halfSize,  // 0
        halfSize, 0, -halfSize,   // 1
        halfSize, 0, halfSize,    // 2
        -halfSize, 0, halfSize,   // 3
        
        // Sommet biseaut√© (y = height, d√©cal√© vers l'avant)
        -halfSize * 0.3, height, -halfSize * 0.3,  // 4
        halfSize * 0.3, height, -halfSize * 0.3,   // 5
        halfSize * 0.3, height, halfSize * 0.3,    // 6
        -halfSize * 0.3, height, halfSize * 0.3    // 7
      ]);
      
      // D√©finir les faces (triangles)
      const indices = [
        // Base
        0, 2, 1,  0, 3, 2,
        
        // C√¥t√©s
        0, 1, 5,  0, 5, 4,  // Face avant
        1, 2, 6,  1, 6, 5,  // Face droite
        2, 3, 7,  2, 7, 6,  // Face arri√®re
        3, 0, 4,  3, 4, 7,  // Face gauche
        
        // Sommet
        4, 5, 6,  4, 6, 7
      ];
      
      geometry.setIndex(indices);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    
    function calculateAccessibleCells(fromRow, fromCol, range) {
      // Calculer les cases accessibles depuis une position donn√©e avec un range
      const accessible = [];
      const visited = new Set();
      const queue = [{ row: fromRow, col: fromCol, distance: 0 }];
      
      visited.add(`${fromRow}-${fromCol}`);
      
      // Ajouter la case de d√©part comme accessible (distance 0)
      accessible.push({ row: fromRow, col: fromCol, distance: 0 });
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.distance >= range) continue;
        
        // V√©rifier les 4 directions (haut, bas, gauche, droite)
        const directions = [
          { dr: -1, dc: 0 },  // Haut
          { dr: 1, dc: 0 },   // Bas
          { dr: 0, dc: -1 },  // Gauche
          { dr: 0, dc: 1 }    // Droite
        ];
        
        for (const dir of directions) {
          const newRow = current.row + dir.dr;
          const newCol = current.col + dir.dc;
          const key = `${newRow}-${newCol}`;
          
          // V√©rifier les limites et si la case est une route
          if (newRow >= 0 && newRow < boardSize && 
              newCol >= 0 && newCol < boardSize && 
              cityMap[newRow][newCol] && 
              !visited.has(key)) {
            
            visited.add(key);
            
            // V√©rifier si la case n'est pas occup√©e par un autre pion
            const isOccupied = pions.some(p => 
              p !== redPion && p.userData.row === newRow && p.userData.col === newCol
            );
            
            if (!isOccupied) {
              accessible.push({ row: newRow, col: newCol, distance: current.distance + 1 });
              queue.push({ row: newRow, col: newCol, distance: current.distance + 1 });
            }
          }
        }
      }
      
      return accessible;
    }
    
    function highlightAccessibleCells() {
      // Retirer la surbrillance de toutes les cases
      clearHighlights();
      
      if (!redPion) return;
      
      // Calculer les cases accessibles
      accessibleCells = calculateAccessibleCells(
        redPion.userData.row, 
        redPion.userData.col, 
        moveRange
      );
      
      // Mettre en surbrillance les cases accessibles
      accessibleCells.forEach(cell => {
        const key = `${cell.row}-${cell.col}`;
        const square = squareMeshes[key];
        if (square) {
          square.material.color.setHex(0xffff99); // Jaune clair
        }
      });
    }
    
    function clearHighlights() {
      // Restaurer la couleur originale de toutes les cases
      for (const key in squareMeshes) {
        const square = squareMeshes[key];
        square.material.color.setHex(square.userData.originalColor);
      }
    }
    
    function startPlayerTurn() {
      isPlayerTurn = true;
      highlightAccessibleCells();
      console.log("Tour du joueur - D√©placez-vous dans les cases surlign√©es, puis appuyez sur la flamme");
    }
    
    function endPlayerTurn() {
      isPlayerTurn = false;
      clearHighlights();
      console.log("Tour de l'adversaire");
      
      // V√©rifier s'il y a un pion adverse adjacent au pion rouge
      if (isEnemyAdjacentToRedPion()) {
        // D√©clencher la phase de confrontation
        openConfrontation();
      } else {
        // Continuer directement le tour de l'adversaire
        setTimeout(() => {
          aiTurn();
        }, 500);
      }
    }
    
    function isEnemyAdjacentToRedPion() {
      if (!redPion) return false;
      
      const redRow = redPion.userData.row;
      const redCol = redPion.userData.col;
      
      // V√©rifier les 4 cases adjacentes (haut, bas, gauche, droite)
      const adjacentPositions = [
        { row: redRow - 1, col: redCol },     // Haut
        { row: redRow + 1, col: redCol },     // Bas
        { row: redRow, col: redCol - 1 },     // Gauche
        { row: redRow, col: redCol + 1 }      // Droite
      ];
      
      // V√©rifier si un pion adverse (pas le rouge) est sur une case adjacente
      for (const pos of adjacentPositions) {
        const enemyOnCell = pions.find(p => 
          p !== redPion && 
          p.userData.row === pos.row && 
          p.userData.col === pos.col
        );
        
        if (enemyOnCell) {
          console.log("Pion adverse adjacent d√©tect√© - Confrontation d√©clench√©e!");
          confrontedPion = enemyOnCell; // M√©moriser le pion confront√©
          return true;
        }
      }
      
      return false;
    }
    
    function openConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.add('active');
      console.log("Phase Confrontation d√©clench√©e");
    }
    
    function closeConfrontation() {
      const panel = document.getElementById('confrontation-panel');
      panel.classList.remove('active');
      console.log("Phase Confrontation termin√©e");
      
      // Replacer le pion confront√© ailleurs sur l'√©chiquier
      if (confrontedPion) {
        relocateConfrontedPion(confrontedPion);
        confrontedPion = null; // R√©initialiser
      }
      
      // Continuer le tour de l'adversaire apr√®s la fermeture
      setTimeout(() => {
        aiTurn();
      }, 500);
    }
    
    function relocateConfrontedPion(pion) {
      // Trouver une case route libre (non occup√©e par un autre pion)
      const freeCells = roadPositions.filter(road => {
        // V√©rifier qu'aucun pion n'occupe cette case
        const isOccupied = pions.some(p => 
          p.userData.row === road.row && p.userData.col === road.col
        );
        return !isOccupied;
      });
      
      if (freeCells.length > 0) {
        // Choisir une case al√©atoire parmi les cases libres
        const newCell = freeCells[Math.floor(Math.random() * freeCells.length)];
        movePion(pion, newCell.row, newCell.col);
        console.log(`Pion confront√© replac√© √† la position (${newCell.row}, ${newCell.col})`);
      } else {
        console.log("Aucune case libre disponible pour replacer le pion confront√©");
      }
    }
    
    function aiTurn() {
      // L'IA choisit un pion au hasard (pas le rouge) et le d√©place
      const aiPions = pions.filter(p => p !== redPion);
      if (aiPions.length === 0) {
        startPlayerTurn();
        return;
      }
      
      const selectedPion = aiPions[Math.floor(Math.random() * aiPions.length)];
      const aiAccessible = calculateAccessibleCells(
        selectedPion.userData.row,
        selectedPion.userData.col,
        moveRange
      );
      
      if (aiAccessible.length > 0) {
        const targetCell = aiAccessible[Math.floor(Math.random() * aiAccessible.length)];
        movePion(selectedPion, targetCell.row, targetCell.col);
      }
      
      // Retour au tour du joueur
      setTimeout(() => {
        startPlayerTurn();
      }, 500);
    }
    
    function movePion(pion, toRow, toCol) {
      // D√©placer un pion vers une nouvelle case
      pion.userData.row = toRow;
      pion.userData.col = toCol;
      
      const x = (toCol - (boardSize - 1) / 2) * squareSize;
      const z = (toRow - (boardSize - 1) / 2) * squareSize;
      
      pion.userData.baseX = x;
      pion.userData.baseZ = z;
      
      const pionHeight = pion.scale.y;
      pion.position.set(x, pionHeight / 2, z);
    }
    
    function createPionTexture(color) {
      // Cr√©er une texture pour un pion d'une couleur donn√©e
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 170;
      const ctx = canvas.getContext('2d');
      
      // Fond transparent
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner un pion simple (cercle + base)
      // Positionner pour que le bas de l'image soit le point d'ancrage
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(64, 50, 40, 0, Math.PI * 2);
      ctx.fill();
      
      // Base plus fonc√©e
      const darkColor = shadeColor(color, -30);
      ctx.fillStyle = darkColor;
      ctx.fillRect(50, 90, 28, 60);
      ctx.beginPath();
      ctx.ellipse(64, 150, 25, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      
      return new THREE.CanvasTexture(canvas);
    }
    
    function shadeColor(color, percent) {
      // Fonction pour assombrir une couleur
      const num = parseInt(color.replace("#",""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
        (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
        .toString(16).slice(1);
    }
    
    function createAllPions() {
      // Supprimer tous les anciens pions
      pions.forEach(p => checkerboard.remove(p));
      pions = [];
      redPion = null;
      
      // Cr√©er un ensemble pour suivre les cases occup√©es
      const occupiedPositions = new Set();
      
      // S'assurer qu'il y a assez de routes pour tous les pions
      if (roadPositions.length < 9) {
        console.error("Pas assez de routes pour placer tous les pions!");
        return;
      }
      
      // Cr√©er chaque type de pion
      pionTypes.forEach((type, typeIndex) => {
        for (let i = 0; i < type.count; i++) {
          // Trouver une position al√©atoire libre sur une route
          let roadIndex, position, posKey;
          let attempts = 0;
          do {
            roadIndex = Math.floor(Math.random() * roadPositions.length);
            position = roadPositions[roadIndex];
            posKey = `${position.row}-${position.col}`;
            attempts++;
            if (attempts > 1000) {
              console.error("Impossible de trouver une position libre!");
              return;
            }
          } while (occupiedPositions.has(posKey));
          
          occupiedPositions.add(posKey);
          
          // Cr√©er le pion
          const texture = createPionTexture(type.color);
          const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true
          });
          
          const pion = new THREE.Sprite(material);
          const pionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const pionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pion.scale.set(pionScale, pionHeight, 1);
          
          // Positionner le pion sur la case
          // Le centre du bas de l'image doit √™tre au centre de la case
          const x = (position.col - (boardSize - 1) / 2) * squareSize;
          const z = (position.row - (boardSize - 1) / 2) * squareSize;
          // D√©calage vertical : la moiti√© de la hauteur du sprite pour que le bas soit sur la case
          pion.position.set(x, pionHeight / 2, z);
          
          // Stocker les coordonn√©es du pion et sa position de base
          pion.userData = { 
            row: position.row, 
            col: position.col,
            baseX: x,
            baseZ: z
          };
          
          checkerboard.add(pion);
          pions.push(pion);
          
          // Garder une r√©f√©rence au pion rouge (premier pion du premier type)
          if (typeIndex === 0 && i === 0) {
            redPion = pion;
          }
        }
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Animation de rotation progressive
      if (isRotating) {
        const diff = targetRotation - checkerboard.rotation.y;
        if (Math.abs(diff) > 0.01) {
          checkerboard.rotation.y += diff * 0.1;
          
          // Si on est zoom√©, mettre √† jour la position de la cam√©ra pour suivre le pion rouge
          if (isZoomed && redPion) {
            const redPionWorldPos = new THREE.Vector3();
            redPion.getWorldPosition(redPionWorldPos);
            
            targetCameraPos = {
              x: redPionWorldPos.x,
              y: 3,
              z: redPionWorldPos.z + 2.5
            };
            targetCameraLookAt = {
              x: redPionWorldPos.x,
              y: 0,
              z: redPionWorldPos.z
            };
            
            camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
            camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          }
        } else {
          checkerboard.rotation.y = targetRotation;
          isRotating = false;
        }
      }
      
      // Animation de zoom progressive
      if (isZooming) {
        const posXDiff = targetCameraPos.x - camera.position.x;
        const posYDiff = targetCameraPos.y - camera.position.y;
        const posZDiff = targetCameraPos.z - camera.position.z;
        
        if (Math.abs(posXDiff) > 0.01 || Math.abs(posYDiff) > 0.01 || Math.abs(posZDiff) > 0.01) {
          camera.position.x += posXDiff * 0.1;
          camera.position.y += posYDiff * 0.1;
          camera.position.z += posZDiff * 0.1;
          
          // Mettre √† jour la cible de la cam√©ra
          const lookAtX = targetCameraLookAt.x;
          const lookAtY = targetCameraLookAt.y;
          const lookAtZ = targetCameraLookAt.z;
          camera.lookAt(lookAtX, lookAtY, lookAtZ);
          
          // Mettre √† jour la taille des pions progressivement
          const zoomProgress = isZoomed ? 
            1 - Math.abs(posYDiff) / (12 - 3) : 
            Math.abs(posYDiff) / (12 - 3);
          const pionScale = squareSize * (0.8 + zoomProgress * 1.2);
          const pionHeight = squareSize * (1.1 + zoomProgress * 1.4);
          
          pions.forEach(p => {
            p.scale.set(pionScale, pionHeight, 1);
            // Maintenir le pion ancr√© au centre de sa case
            p.position.y = pionHeight / 2;
          });
        } else {
          camera.position.set(targetCameraPos.x, targetCameraPos.y, targetCameraPos.z);
          camera.lookAt(targetCameraLookAt.x, targetCameraLookAt.y, targetCameraLookAt.z);
          isZooming = false;
          
          // Fixer la taille finale des pions
          const finalPionScale = isZoomed ? squareSize * 2 : squareSize * 0.8;
          const finalPionHeight = isZoomed ? squareSize * 2.5 : squareSize * 1.1;
          pions.forEach(p => {
            p.scale.set(finalPionScale, finalPionHeight, 1);
            // Maintenir le pion ancr√© au centre de sa case
            p.position.y = finalPionHeight / 2;
          });
        }
      }
      
      renderer.render(scene, camera);
    }
    
    // Gestionnaire des boutons
    document.getElementById('rotateRightBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation += Math.PI / 2; // +90 degr√©s
      }
    });
    
    document.getElementById('rotateLeftBtn').addEventListener('click', function() {
      if (!isRotating) {
        isRotating = true;
        targetRotation -= Math.PI / 2; // -90 degr√©s
      }
    });
    
    document.getElementById('zoomBtn').addEventListener('click', function() {
      if (!isZooming && redPion) {
        isZooming = true;
        isZoomed = !isZoomed;
        
        if (isZoomed) {
          // Vue rapproch√©e : centrer sur le pion rouge
          const redPionWorldPos = new THREE.Vector3();
          redPion.getWorldPosition(redPionWorldPos);
          
          // Cam√©ra plus proche et plus horizontale
          targetCameraPos = {
            x: redPionWorldPos.x,
            y: 3,  // Beaucoup plus bas qu'avant (√©tait 12)
            z: redPionWorldPos.z + 2.5  // Plus proche
          };
          targetCameraLookAt = {
            x: redPionWorldPos.x,
            y: 0,
            z: redPionWorldPos.z
          };
          
          this.textContent = 'UnZoom';
        } else {
          // Vue g√©n√©rale
          targetCameraPos = { x: 0, y: 12, z: 10 };
          targetCameraLookAt = { x: 0, y: 0, z: 0 };
          
          this.textContent = 'Zoom';
        }
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', function() {
      // R√©g√©n√©rer le r√©seau routier
      checkerboard.clear();
      
      // R√©g√©n√©rer le damier avec un nouveau plan
      cityMap = generateCityMap();
      roadPositions = [];
      squareMeshes = {};
      
      // Ajouter les lieux dits
      const landmarks = addLandmarks(cityMap);
      
      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
          const geometry = new THREE.BoxGeometry(squareSize, 0.15, squareSize);
          
          // V√©rifier si c'est un landmark
          const landmark = landmarks.find(l => l.row === row && l.col === col);
          
          let material;
          if (landmark) {
            // C'est un lieu dit
            material = new THREE.MeshBasicMaterial({ color: landmark.color });
          } else {
            // D√©terminer si c'est une route ou un b√¢timent
            const isRoad = cityMap[row][col];
            material = new THREE.MeshBasicMaterial({ 
              color: isRoad ? 0xcccccc : 0x444444
            });
            
            if (isRoad) {
              roadPositions.push({ row, col });
            }
          }
          
          const square = new THREE.Mesh(geometry, material);
          
          // Positionner chaque case
          square.position.x = (col - (boardSize - 1) / 2) * squareSize;
          square.position.z = (row - (boardSize - 1) / 2) * squareSize;
          
          // Stocker le mesh pour pouvoir le modifier plus tard
          square.userData = { row, col, originalColor: material.color.getHex(), isRoad: cityMap[row][col] };
          squareMeshes[`${row}-${col}`] = square;
          
          // Ajouter des bordures
          const edges = new THREE.EdgesGeometry(geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          square.add(wireframe);
          
          checkerboard.add(square);
          
          // Si c'est un landmark, ajouter un immeuble 3D
          if (landmark) {
            const building = createBuilding(landmark.type, squareSize);
            building.position.x = (col - (boardSize - 1) / 2) * squareSize;
            building.position.z = (row - (boardSize - 1) / 2) * squareSize;
            checkerboard.add(building);
          }
        }
      }
      
      // Cr√©er les nouveaux pions
      createAllPions();
      
      // R√©initialiser le zoom si on √©tait zoom√©
      if (isZoomed) {
        isZoomed = false;
        isZooming = false;
        camera.position.set(0, 12, 10);
        camera.lookAt(0, 0, 0);
        targetCameraPos = { x: 0, y: 12, z: 10 };
        targetCameraLookAt = { x: 0, y: 0, z: 0 };
        document.getElementById('zoomBtn').textContent = 'Zoom';
      }
      
      // Red√©marrer le tour du joueur
      startPlayerTurn();
    });
    
    // Gestionnaires pour la croix directionnelle
    document.getElementById('dpad-UR').addEventListener('click', function() {
      if (isPlayerTurn) {
        // Haut = row--
        movePlayerOneStep(-1, 0);
      }
    });
    
    document.getElementById('dpad-BR').addEventListener('click', function() {
      if (isPlayerTurn) {
        // Droite = col++
        movePlayerOneStep(0, 1);
      }
    });
    
    document.getElementById('dpad-BL').addEventListener('click', function() {
      if (isPlayerTurn) {
        // Bas = row++
        movePlayerOneStep(1, 0);
      }
    });
    
    document.getElementById('dpad-UL').addEventListener('click', function() {
      if (isPlayerTurn) {
        // Gauche = col--
        movePlayerOneStep(0, -1);
      }
    });
    
    function movePlayerOneStep(deltaRow, deltaCol) {
      if (!redPion || !isPlayerTurn) return;
      
      // Calculer la case cible (une seule case de distance)
      const targetRow = redPion.userData.row + deltaRow;
      const targetCol = redPion.userData.col + deltaCol;
      
      // V√©rifier si la case cible est dans les cases accessibles
      const isAccessible = accessibleCells.some(cell => 
        cell.row === targetRow && cell.col === targetCol
      );
      
      if (isAccessible) {
        movePion(redPion, targetRow, targetCol);
        console.log("Pion d√©plac√© - Continuez ou appuyez sur la flamme pour terminer votre tour");
      } else {
        console.log("Case non accessible");
      }
    }
    
    document.getElementById('dpad-center').addEventListener('click', function() {
      console.log('Action: Flamme - Fin du tour du joueur');
      // Terminer le tour du joueur
      if (isPlayerTurn) {
        endPlayerTurn();
      }
    });
    
    // Gestionnaire pour le bouton de fermeture de la confrontation
    document.getElementById('close-confrontation-btn').addEventListener('click', function() {
      closeConfrontation();
    });
    
    init();
  </script>
</body>
</html>